<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0" />
  <title>BBB Golf</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="icon.png" /> 
  <meta id="cacheBuster" name="version" content="20251123-FORCE-CACHE" />

  <style>
 
html, body {
  margin: 0;
  padding: 0;
  height: 100vh;
  overflow-y: auto;
  overflow-x: hidden;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  scroll-padding-top: env(safe-area-inset-top, 0px);
  -webkit-overflow-scrolling: touch;
}

body {
  position: static;
  overscroll-behavior-y: contain;
  padding-top: env(safe-area-inset-top, 0px);
}


    :root {
      --bg: #f4f4f4;
      --card: #fff;
      --text: #222;
      --green: #0f0;
      --btn-bg: #0f0;
      --btn-text: #000;
      --table-header: #555;
      --table-bg: #eee;
    }
    [data-theme="dark"] {
      --bg: #111;
      --card: #222;
      --text: #eee;
      --green: #0f0;
      --btn-bg: #0f0;
      --btn-text: #000;
      --table-header: #444;
      --table-bg: #333;
    }

    * { box-sizing: border-box; }

    body {
  background: var(--bg);
  color: var(--text);
  line-height: 1.5;
  margin: 0;
  padding: 0;
  min-height: 100vh;
  scroll-padding-top: env(safe-area-inset-top, 0px);
  -webkit-overflow-scrolling: touch;
}

    .card {
  background: var(--card);
  padding: 1rem;
  border-radius: 12px;
  margin: 0 auto 1rem;
  max-width: 800px;
  width: 100%;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

/* FIX EMPTY SPACE ON MOBILE — PLAYER SETUP & GAME SCREEN */
#playerSetup,
#game {
  padding-top: 0.3rem !important;
  min-height: auto !important;
}

#playerSetup > div,
#game > div:first-child {
  margin-top: 0.2rem !important;
}




    #courseSetup, #playerSetup, #game, #summary {
      display: flex;
      flex-direction: column;
    }

    h1 { 
      color: var(--green); 
      text-align: center; 
      margin: 0.5rem 0; 
      font-size: 1.4rem; 
    }

    button {
      background: var(--btn-bg);
      color: var(--btn-text);
      border: none;
      padding: 0.75rem 1rem;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      margin: 0.25rem;
    }
    button:disabled { opacity: 0.4; cursor: not-allowed; }

    
    .hidden {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }

    .center-block { 
      max-width: 800px; 
      margin: 0 auto; 
      width: 100%; 
    }

    #holeDisplay {
      font-size: 1.1rem;
      font-weight: 600;
      text-align: center;
      margin: 0.5rem 0;
    }

    #scoreTable { 
      width: 100%; 
      max-width: 800px; 
      margin: 0.5rem auto; 
      border-collapse: collapse; 
    }
    #scoreTable th, #scoreTable td { 
      padding: 0.75rem; 
      text-align: center; 
      border-bottom: 1px solid #ddd; 
    }
    #scoreTable th { 
      background: var(--table-header); 
      color: #fff; 
      font-weight: 600; 
    }
    #scoreTable th:first-child, #scoreTable td:first-child { text-align: left; }
    tbody tr:nth-child(even) { background: var(--table-bg); }

    /* === CHECKBOXES: FINAL VERSION (NO DUPLICATES) === */
    input[type="checkbox"] {
      width: 28px;
      height: 28px;
      transform: scale(1.6);
      margin: 0 6px;
      cursor: pointer;
    }

  

 /* GROK: Final game screen spacing — tight top, comfy bottom */
#game {
  padding: 0.4rem 0 1.5rem 0 !important;  /* Top reduced, bottom preserved for control bar */
}



    /* === COURSE SETUP (ONLY ONCE) === */
    #courseSetup {
      padding: 1rem !important;
      display: flex !important;
      flex-direction: column !important;
      align-items: stretch !important;
    }
    #courseSetup > div {
      display: flex !important;
      flex-direction: column !important;
      gap: 0.5rem !important;
      align-items: center !important;
    }
    #courseSelect, #addCourse, #nextToPlayers {
      width: 100% !important;
      max-width: none !important;
      font-size: 1rem !important;
      padding: 0.75rem !important;
    }
    #nextToPlayers:disabled {
      opacity: 0.4 !important;
      background: #ccc !important;
      cursor: not-allowed !important;
    }

    /* PLAYER SETUP & START ROUND */
    #playerSetup {
      padding: 1rem 1rem 160px 1rem !important;
      overflow: visible !important;
    }

    #playerSetup > div[style*="margin-top: 1rem"] {
      margin-top: 1.5rem !important;
      padding: 0.5rem !important;
      background: var(--card) !important;
      border-radius: 8px !important;
      display: block !important;
      width: 100% !important;
      box-sizing: border-box !important;
    }

    #startGame {
      width: 100% !important;
      max-width: none !important;
      padding: 1.2rem !important;
      font-size: 1.2rem !important;
      min-height: 60px !important;
      background: var(--btn-bg) !important;
      color: var(--btn-text) !important;
      border: none !important;
      border-radius: 12px !important;
      font-weight: bold !important;
      cursor: pointer !important;
      box-sizing: border-box !important;
    }
    #startGame:disabled {
      opacity: 0.6 !important;
      background: #ccc !important;
      color: #999 !important;
      cursor: not-allowed !important;
    }

    .holeSummary,
#roundSummary {
  margin: 0.4rem auto !important;
  padding: 0.4rem !important;
  line-height: 1.3 !important;
  font-size: 0.88rem !important;   /* ← was 0.82rem — now matches round summary */
  font-weight: 600 !important;
  text-align: center;
  background: #fff !important;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  border: 1px solid #d4edda;
  max-width: 800px;
}

.holeSummary {
  color: #dc3545 !important;
}

#roundSummary {
  color: #dc3545 !important;
}

    #roundSummary small { 
      color: #a00 !important;
      font-weight: normal;
      font-size: 0.76rem !important;
    }

    /* ONE-LINE TIGHT LAYOUT */
    .holeSummary > div,
    .summary-awarded,
    .summary-carry-in,
    .summary-no-carry {
      margin: 0 !important;
      padding: 0 !important;
      font-size: 0.78rem !important;
      line-height: 1.2 !important;
    }

    .audit-good { color: #0f0; } 
    .audit-bad { color: #f00; }
    .audit-line { margin-top: 0.5rem; font-size: 0.85rem; line-height: 1.5; }
    .history-item { background: var(--card); padding: 0.75rem; margin: 0.5rem 0; border-radius: 8px; cursor: pointer; }
    .player-tag { display: inline-block; background: #0f0; color: #000; padding: 0.25rem 0.5rem; border-radius: 6px; margin: 0.25rem; font-size: 0.85rem; }

   

#bbbHelpBtn {
  transition: color 0.2s;
}
#bbbHelpBtn:hover, #bbbHelpBtn:focus {
  color: #090;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.control-bar button.pulsing {
  animation: pulse 1.5s infinite;
  background: #00ff00 !important;
  font-weight: bold;
}




/* ABSOLUTE FINAL KILL ALL TOP SPACE — PLAYER SETUP & GAME */
#playerSetup,
#game {
  padding-top: 0 !important;
  margin-top: 0 !important;
}

#playerSetup > *,
#game > * {
  margin-top: 0 !important;
  padding-top: 0 !important;
}

/* Kill specific inline-style offenders */
#playerSetup > div[style*="margin-top"],
#game > div[style*="margin-top"],
#game > div[style*="display:flex"] {
  margin-top: 0 !important;
  padding-top: 0 !important;
}

/* Tighten the hole header and table */
#holeDisplay {
  margin: 0.4rem 0 0.2rem 0 !important;
  padding: 0 !important;
}

#scoreTable {
  margin-top: 0.3rem !important;
}

#backToCourse {
  background: #ccc;
  color: #000;
  font-size: 0.9rem;
  padding: 0.5rem 1rem;
  margin-bottom: 1rem;
}

/* FINAL CONTROL BAR — SMALLER, SUBTLE, CENTERED */
.control-bar {
  padding: 0.6rem 0.4rem !important;
  gap: 0.6rem !important;
  display: flex !important;
  flex-wrap: wrap !important;
  justify-content: flex-start !important;   /* ← changed from center */
  align-items: center !important;
  background: var(--card) !important;
  border-top: 1px solid rgba(0,0,0,0.1);
}

.control-bar button {
  min-width: 64px !important;      /* smaller than before */
  height: 38px !important;         /* shorter */
  padding: 0 0.6rem !important;
  font-size: 0.8rem !important;    /* slightly smaller text */
  font-weight: bold !important;
  border-radius: 10px !important;
  background: #00cc00 !important; /* slightly darker/muted green so it doesn’t scream */
  color: #000 !important;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

/* PLAYER SELECT — TWO-COLUMN GRID (perfect on every phone) */
#playerSelect {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 0.8rem 1rem;
  max-width: 700px;
  margin: 0 auto;
  padding: 0 1rem;
}

#playerSelect label {
  display: flex;
  align-items: center;
  gap: 0.6rem;
  font-size: 1.1rem;
  white-space: nowrap;
  overflow: hidden;
}

/* Bigger checkboxes on phone */
@media (max-width: 768px) {
  #playerSelect {
    grid-template-columns: 1fr 1fr;   /* forces exactly 2 columns on phone */
    gap: 0.9rem 1rem;
    padding: 0 1.5rem;
  }
  #playerSelect input[type="checkbox"] {
    width: 24px !important;
    height: 24px !important;
    transform: scale(1.3) !important;
  }
}


/* FINAL — SCORING TABLE ALWAYS AT THE TOP, NO EMPTY SPACE */
#game {
  padding-top: 0.2rem !important;
  padding-bottom: 1rem !important;
}

/* Kill every possible top margin/padding above the table */
#scoreTable */
#game > div:first-child,
#holeDisplay,
#scoreTable {
  margin-top: 0 !important;
  margin-bottom: 0.4rem !important;
  padding-top: 0 !important;
}

/* Make sure the table itself starts immediately */
#scoreTable {
  margin-top: 0.6rem !important;
}

/* Mobile insurance */
@media (max-width: 768px) {
  #game {
    padding: 0.2rem 0.6rem 1rem !important;
  }
  #holeDisplay {
    margin: 0.2rem 0 0.4rem 0 !important;
  }
}


/* CHECKBOXES — 50% SMALLER ON PHONE ONLY */
@media (max-width: 768px) {
  input[type="checkbox"] {
    width: 18px !important;     /* was ~28px → now 18px */
    height: 18px !important;
    transform: scale(1) !important;   /* removes the 1.6 scale */
    margin: 0 6px !important;
  }
}

/* Optional: make them a touch bigger on PC for mouse users */
@media (min-width: 769px) {
  input[type="checkbox"] {
    width: 22px !important;
    height: 22px !important;
    transform: scale(1.2) !important;
  }
}

/* FINAL — SCORING TABLE FITS EVERY PHONE, TOT ALWAYS VISIBLE */
#scoreTable {
  table-layout: fixed;            /* forces columns to respect widths */
  width: 100% !important;
  margin-top: 0.4rem !important;
}

#scoreTable th:nth-child(1),     /* Player name */
#scoreTable td:nth-child(1) {
  width: 28% !important;         /* gives names plenty of room */
  text-align: left !important;
  padding-left: 0.6rem !important;
}

#scoreTable th:nth-child(2),     /* FO/GR */
#scoreTable td:nth-child(2),
#scoreTable th:nth-child(3),     /* CL */
#scoreTable td:nth-child(3),
#scoreTable th:nth-child(4),     /* P */
#scoreTable td:nth-child(4) {
  width: 12% !important;         /* tiny columns for the 3 checkboxes */
}

#scoreTable th:nth-child(5),     /* H (hole points) */
#scoreTable td:nth-child(5) {
  width: 14% !important;
}

#scoreTable th:nth-child(6),     /* RUN */
#scoreTable td:nth-child(6),
#scoreTable th:nth-child(7),     /* TOT */
#scoreTable td:nth-child(7) {
  width: 17% !important;         /* gives RUN and TOT breathing room */
  font-weight: bold !important;
}

/* Mobile — even tighter if needed */
@media (max-width: 480px) {
  #scoreTable th, #scoreTable td {
    padding: 0.4rem 0.2rem !important;
    font-size: 0.9rem !important;
  }
  #scoreTable th:nth-child(1), td:nth-child(1) {
    font-size: 0.95rem !important;
  }
}

/* TOP NAV BUTTONS — BIGGER AND BOLDER (Prev / Next / Edit / Finish) */
#game > div:first-child > div > button {
  height: 46px !important;
  min-width: 80px !important;
  padding: 0 1rem !important;
  font-size: 1.05rem !important;
  font-weight: bold !important;
  border-radius: 12px !important;
}

/* CONTROL-BAR BUTTONS — ~30% SMALLER AND MORE SUBTLE */
.control-bar {
  padding: 0.4rem 0 !important;
  gap: 0.5rem !important;
  justify-content: center !important;
}

.control-bar button {
  min-width: 62px !important;     /* was ~90px → now ~30% smaller */
  height: 36px !important;        /* was 48px → now smaller */
  padding: 0 0.6rem !important;
  font-size: 0.78rem !important;  /* was 0.9rem */
  font-weight: bold !important;
  border-radius: 10px !important;
  background: #00bb00 !important; /* slightly darker so they recede */
}

/* HELP button stays on the right */
#bbbHelpBtn {
  margin-left: auto !important;
}




/* FINAL — HOLE & ROUND SUMMARIES: ALL RED, CLEAN, MATH VISIBLE */
.holeSummary,
#roundSummary {
  padding: 0.5rem 0.8rem !important;
  font-size: 0.9rem !important;
  line-height: 1.4 !important;
  text-align: center !important;
  color: #dc3545 !important;           /* everything red */
  background: #fff !important;
  border-radius: 12px !important;
  box-shadow: 0 1px 4px rgba(0,0,0,0.1);
  border: 1px solid #f8d7da;
}

/* Only the numbers are bold */
.holeSummary strong,
#roundSummary strong {
  font-weight: bold !important;
}

/* Expected line — smaller and shows the math */
#roundSummary small {
  display: block;
  font-size: 0.78rem !important;
  margin-top: 0.3rem !important;
  color: #a00 !important;
}


/* HOLE COLUMN NUMBERS — SAME STYLE AS TOT COLUMN */
#scoreTable td:nth-child(5) strong {   /* H column = 5th column */
  color: inherit !important;           /* same as TOT (black in light mode, white in dark) */
  font-weight: 600 !important;         /* same boldness as TOT */
  font-size: 1.1em !important;
}


#courseSetup.hidden { height:0 !important; overflow:hidden !important; padding:0 !important; margin:0 !important; }

/* Push content down when banner is visible */
body.practice-mode {
  padding-top: 50px !important;
}

#practiceBanner {
  display: flex !important;
}




</style>
</head>

<body>

  <!-- PRACTICE MODE BANNER -->
<div id="practiceBanner" class="hidden" style="
  position:fixed;top:0;left:0;width:100%;background:#ffeb3b;color:#b71c1c;
  padding:0.6rem 1rem;font-weight:bold;text-align:center;
  z-index:9999;font-size:0.9rem;display:flex;justify-content:center;align-items:center;gap:1rem;
  box-shadow:0 2px 6px rgba(0,0,0,0.2);
">
  <span>PRACTICE MODE (No SMS)</span>
  <label style="margin:0;cursor:pointer;display:flex;align-items:center;gap:0.4rem;">
    <input type="checkbox" id="practiceToggle"> <span style="font-size:0.85rem;">ON</span>
  </label>
</div>



   <!-- 1. LAUNCH SCREEN (only shows on root page) -->
  <div id="launchWrapper" style="text-align:center; padding:40px 20px; background:#f9f9f9; min-height:100vh; display:flex; flex-direction:column; justify-content:center;">
    <h1 style="font-size:28px; margin-bottom:10px; color:#0f0;">BBB Golf Scorer</h1>
    <p style="margin-bottom:30px; color:#555; font-size:1.1rem;">Tap below to open the app<br><small>(works perfectly on iPhone & Android)</small></p>
    <a href="/bbb-scorer/" 
       onclick="localStorage.setItem('appLaunched','true'); window.open('/bbb-scorer/', '_blank'); return false;"
       style="display:inline-block; padding:18px 40px; background:#2e7d32; color:white; font-size:20px; font-weight:bold; text-decoration:none; border-radius:12px; box-shadow:0 4px 10px rgba(0,0,0,0.2);">
       Launch Golf Scorer
    </a>
    <p style="margin-top:30px; font-size:14px; color:#666;">
      Pro tip: Bookmark <em>this</em> page and add it to your home screen for one-tap access!
    </p>
  </div>

  <!-- 2. AUTO-HIDE LAUNCH SCREEN + SPINNER KILLER -->
<script>
  // Hide launch screen
  if (window.location.pathname === '/bbb-scorer/' || window.location.pathname === '/bbb-scorer/index.html') {
    document.getElementById('launchWrapper')?.remove();
  }
  else if (localStorage.getItem('appLaunched')) {
    window.location.href = '/bbb-scorer/';
  }

  /* // FINAL DIAGNOSTIC — tells us exactly what’s happening
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      const loader = document.getElementById('courseLoader');
      const picker = document.getElementById('coursePicker');
      if (loader) loader.remove();
      if (picker) {
        picker.classList.remove('hidden');
        picker.style.display = 'block';
      }

      // DIAGNOSTIC LINES — these will appear in your green debug panel
      console.log('courses array length:', (window.courses || []).length);
      console.log('courses array contents:', window.courses);
      console.log('renderCourseSelect exists?', typeof renderCourseSelect);

      if (typeof renderCourseSelect === 'function') {
        renderCourseSelect();
        console.log('renderCourseSelect() FORCED — dropdown should now have courses');
      } else {
        console.error('renderCourseSelect is missing — check app-v23.js');
      }
    }, 3000);
  }); */
</script>

<!-- YOUR ENTIRE APP CODE INLINED BELOW   SCRIPT START-->  
  <script>
    console.log('app-v23.js INLINED — LOADED 100% — 20251122-FINAL-WIN');

    const BACKEND = 'https://pwa-players-backend.onrender.com';
    const VERSION = '20251122-FINAL-WIN';

    let roster = [];
    let players = [];
    let currentHole = 1;
    const HOLES = 18;
    const MAX_PLAYERS = 6;
    let currentCourse = null;
    let courses = [];
    let roundHistory = [];
    let finishedHoles = new Set();
    let inRound = false;
    let isHoleInProgress = false;
    let els = {};
    let waltShadowPhone = null;
    let practiceMode = false;


    //  Async functions here

   / === MAIN DATA LOADER — FINAL BULLETPROOF VERSION (works on iOS standalone)/


 async function loadDataFromBackend() {
  const loader = document.getElementById('courseLoader');
  const error = document.getElementById('courseError');
  const picker = document.getElementById('coursePicker');

  const BACKEND_URL = 'https://pwa-players-backend.onrender.com';

  try {
    console.log('Starting backend load...');

    const [playersRes, coursesRes] = await Promise.all([
      fetch(`${BACKEND_URL}/players`, {
        method: 'GET',
        mode: 'cors',
        credentials: 'omit'
      }),
      fetch(`${BACKEND_URL}/courses`, {
        method: 'GET',
        mode: 'cors',
        credentials: 'omit'
      })
    ]);

    if (!playersRes.ok) throw new Error(`Players ${playersRes.status}`);
    if (!coursesRes.ok) throw new Error(`Courses ${coursesRes.status}`);

    const playersCSV = await playersRes.text();
    const coursesCSV = await coursesRes.text();

    console.log('Raw players CSV length:', playersCSV.length);
    console.log('Raw courses CSV length:', coursesCSV.length);

    // Parse players
    roster = parseCSV(playersCSV).map(p => ({
      name: p.Name?.trim(),
      phone: p.Phone?.trim(),
      email: p.Email?.trim()
    })).filter(p => p.name);

    getWaltPhone();

    // Parse courses
    courses = parseCSV(coursesCSV).map(c => {
      const name = c.Name?.trim();
      const pars = [];
      for (let i = 1; i <= 18; i++) {
        const par = parseInt(c[`Par${i}`]);
        if (!isNaN(par)) pars.push(par);
      }
      return { name, pars };
    }).filter(c => c.name && c.pars.length === 18);

    sortPlayersAlphabetically();

    if (courses.length === 0) throw new Error('No courses returned');

    console.log('%cBackend data loaded successfully!', 'color: gold; font-weight: bold');

    // CRITICAL iOS repaint fix — this is what finally hides the spinner
    setTimeout(() => {
      loader.classList.add('hidden');
      picker.classList.remove('hidden');
      renderCourseSelect();
      console.log('%cCourse picker now visible!', 'color: lime; font-weight: bold');
    }, 0);

  } catch (err) {
    console.error('Backend load failed:', err);
    loader.classList.add('hidden');
    error.classList.remove('hidden');
    error.textContent = `Load failed: ${err.message}`;
  }
}

  async function saveRound() {
  if (!inRound) return;

  const roundData = {
    matchId: currentMatchId,
    date: new Date().toISOString(),
    courseName: currentCourse !== null ? courses[currentCourse]?.name || 'Unknown' : null,
    players: players.map(p => ({ name: p.name, phone: p.phone })),
    currentHole,
    currentCourse,
    currentCourseIndex: currentCourse,
    practiceMode: practiceMode,
    finishedHoles: Array.from(finishedHoles),
    scores: players.reduce((acc, p) => { acc[p.name] = p.scores; return acc; }, {}),
    _cachedTotals: players.reduce((acc, p) => { acc[p.name] = p._cachedTotal || 0; return acc; }, {})
  };

  // Save locally with unique ID
  localStorage.setItem(`bbb_round_${currentMatchId}`, JSON.stringify(roundData));

  // Cloud backup (fire-and-forget)
  fetch('https://pwa-players-backend.onrender.com/save-round', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(roundData)
  }).catch(() => {});
}
 


async function requestWakeLock() {
  if ('wakeLock' in navigator && inRound) {
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      console.log('Wake Lock active — screen stays awake during round');
    } catch (err) {
      console.log('Wake Lock failed (iOS ignores it anyway)', err);
    }
  }
}






    // === PERSISTENCE V2 — MULTIPLE ROUNDS + UNIQUE MATCH ID ===
    let currentMatchId = localStorage.getItem('bbb_currentMatchId');
    if (!currentMatchId) {
      currentMatchId = `BBB-${new Date().toISOString().slice(0,10)}-${Math.random().toString(36).substr(2,5)}`;
      localStorage.setItem('bbb_currentMatchId', currentMatchId);
    }    

    const ENABLE_WALT_SHADOW_TEXT = (!location.hostname.includes('localhost') && location.hostname !== '127.0.0.1');



function getWaltPhone() {
  if (!roster || !Array.isArray(roster)) return;
  const walt = roster.find(p => p.name && p.name.toLowerCase().includes('walt'));
  if (walt && walt.phone) {
    waltShadowPhone = walt.phone.replace(/[^\d+]/g, '');
    console.log('%cWalt shadow phone loaded ✓', 'color: lime; font-weight: bold');
  }
}

// ENHANCED EMERGENCY SPINNER KILLER — polls until picker shows (iOS 18-proof)
(function() {
  let attempts = 0;
  const maxAttempts = 30;  // 3 seconds max
  const interval = setInterval(() => {
    attempts++;
    const loader = document.getElementById('courseLoader');
    const picker = document.getElementById('coursePicker');
    const error = document.getElementById('courseError');
    
    if (loader && picker) {
      // Force-kill loader and error, force-show picker
      loader.style.display = 'none !important';
      if (error) error.style.display = 'none !important';
      picker.style.display = 'block !important';  // or 'flex !important' if your CSS uses flex
      
      // Extra iOS reflow trigger
      picker.offsetHeight;
      
      console.log(`Emergency fallback: Picker forced after ${attempts * 100}ms`);
      clearInterval(interval);
    }
    
    if (attempts >= maxAttempts) {
      console.error('Emergency fallback timed out — manual intervention needed');
      clearInterval(interval);
    }
  }, 100);  // Check every 100ms
})();


/
function logScreen(msg) {
  console.log('%cSCREEN: ' + msg, 'color: cyan; font-weight: bold');
}


// Retry button
document.addEventListener('click', (e) => {
  if (e.target && e.target.id === 'retryBtn') {
    document.getElementById('courseError').classList.add('hidden');
    document.getElementById('courseLoader').classList.remove('hidden');
    loadDataFromBackend();
  }
});

// === CSV PARSER ===
function parseCSV(text) {
  const lines = text.trim().split('\n');
  const headers = lines[0].split(',').map(h => h.trim());
  const rows = lines.slice(1).map(line => {
    const values = [];
    let current = '';
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"' && line[i+1] === '"') { current += '"'; i++; }
      else if (char === '"') inQuotes = !inQuotes;
      else if (char === ',' && !inQuotes) { values.push(current.trim()); current = ''; }
      else current += char;
    }
    values.push(current.trim());
    return values;
  });
  return rows.map(row => {
    const obj = {};
    headers.forEach((h, i) => obj[h] = row[i] || '');
    return obj;
  });
}



function sortPlayersAlphabetically() {
  players.sort((a, b) => a.name.localeCompare(b.name));
  // Also keep roster sorted for consistency in player select screen
  roster.sort((a, b) => a.name.localeCompare(b.name));
}


// === RENDER COURSE SELECT ===
function renderCourseSelect() {
  if (!els.courseSelect) return;
  
  els.courseSelect.innerHTML = '<option value="">-- Select Course --</option>';
  if (courses.length === 0) {
    els.courseSelect.innerHTML += '<option disabled>No courses available</option>';
    els.nextToPlayers.disabled = true;
    return;
  }

  courses.forEach((c, i) => {
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = c.name;
    els.courseSelect.appendChild(opt);
  });

  // FORCE UPDATE THE BUTTON — THIS FIXES MOBILE GREY-OUT BUG
  const updateButton = () => {
    const selected = els.courseSelect.value;
    if (selected !== '' && selected !== null) {
      currentCourse = Number(selected);
      localStorage.setItem('bbb_currentCourse', currentCourse); // ← ADD THIS
      els.nextToPlayers.disabled = false;
    false;
    } else {
      currentCourse = null;
      els.nextToPlayers.disabled = true;
    }
  };

  // Run once immediately
  updateButton();

  // And also run every time the select changes (mobile-safe)
  els.courseSelect.addEventListener('change', updateButton);

  // iOS sometimes needs a tiny delay — this covers all edge cases
  setTimeout(updateButton, 100);
}


   function hideAll() {
  ['courseSetup', 'playerSetup', 'game', 'summary'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.add('hidden');
  });

  // NEVER hide practice banner
  const banner = document.getElementById('practiceBanner');
  if (banner) banner.classList.remove('hidden');
}


function showScreen(id) {
  hideAll();
  const el = document.getElementById(id);
  if (el) el.classList.remove('hidden');

  // RE-APPLY PRACTICE MODE AFTER EVERY SCREEN CHANGE
  if (window.pm) window.pm.apply();
}


  // ←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←
  // CRITICAL: updateNavButtons() MUST BE HERE
  // ←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←
  function updateNavButtons() {
    console.log('%cNAV UPDATE CALLED', 'color: blue; font-weight: bold');
    console.log('currentHole:', currentHole, 'isHoleInProgress:', isHoleInProgress);
    
    const canPrev = currentHole > 1 && !isHoleInProgress;
    const canNext = currentHole < HOLES && !isHoleInProgress;
    
    if (els.prevHole) els.prevHole.disabled = !canPrev;
    if (els.nextHole) els.nextHole.disabled = !canNext;
    
    [els.prevHole, els.nextHole].forEach(btn => {
      if (!btn) return;
      btn.style.opacity = btn.disabled ? '0.5' : '1';
      btn.style.cursor = btn.disabled ? 'not-allowed' : 'pointer';
    });
    
    console.log('%cNAV UPDATE END', 'color: blue; font-weight: bold');
  }

  // ←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←
  // NOW lockNavigation() can safely call it
  // ←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←



function setupGameButtons() {

   console.log('setupGameButtons() CALLED — inRound:', inRound);
  console.log('els.sendSMS:', !!els.sendSMS);
  console.log('els.completeRound:', !!els.completeRound);
  console.log('els.exitRound:', !!els.exitRound);
  console.log('els.darkModeToggle:', !!els.darkModeToggle);
  console.log('els.bbbHelpBtn:', !!els.bbbHelpBtn);




  if (!inRound || currentCourse === null || !courses[currentCourse]) return;

  // CLEAR ANY OLD LISTENERS — prevents double prompts
  const clearButtons = [els.sendSMS, els.completeRound, els.exitRound, els.darkModeToggle, els.bbbHelpBtn];
  clearButtons.forEach(btn => {
    if (btn) btn.onclick = null;
  });

  // SMS BUTTON
  els.sendSMS.onclick = () => {
    if (practiceMode) {
      alert('SMS disabled in Practice Mode');
    return;
}
    const holeIdx = currentHole - 1;
    const par = courses[currentCourse].pars[holeIdx];
    const isPar3 = par === 3;
    let message = `BBB - H${currentHole} (P${par})\n\n`;

    players.forEach(p => {
      const s = p.scores[holeIdx] || {};
      const pts = p._cachedHoleTotals?.[holeIdx] || 0;
      const notes = [];
      if (s.firstOn) notes.push(isPar3 ? 'GR' : 'FO');
      if (s.closest) notes.push('CL');
      if (s.putt) notes.push('P');
      message += `${p.name}: ${pts}${notes.length ? ` (${notes.join('/')})` : ''} | Run: ${getRunningTotal(p)}\n`;
    });

    const carryOut = getCarryInForHole(currentHole + 1);
    const carryTotal = carryOut.firstOn + carryOut.closest + carryOut.putt + carryOut.greenie;
    message += `\nCarry: ${carryTotal}\n\nStandings:\n`;

    const standings = players
      .map(p => ({ name: p.name, total: p._cachedTotal || 0 }))
      .sort((a, b) => b.total - a.total);

    standings.forEach((p, i) => {
      message += `${i + 1}. ${p.name}: ${p.total}\n`;
    });

    // Walt shadow text
    if (ENABLE_WALT_SHADOW_TEXT && waltShadowPhone && finishedHoles.has(currentHole)) {
      const shadowMessage = "LIVE BBB (Walt shadow)\n\n" + message;
      setTimeout(() => {
        window.location.href = `sms:${waltShadowPhone}?body=${encodeURIComponent(shadowMessage)}`;
      }, 1200);
    }

    const phones = players.map(p => p.phone).filter(Boolean).join(',');
    if (!phones) return alert('Add phone numbers');
    window.location.href = `sms:${phones}?body=${encodeURIComponent(message)}`;
  };

  // === FINAL BBB COMP BUTTON IN SUMMARY ===
  document.getElementById('finalBBBComp')?.addEventListener('click', () => {
    if (finishedHoles.size !== HOLES) {
      alert(`Finish all ${HOLES} holes first.`);
      return;
    }
    precomputeAllTotals();
    if (confirm('Round complete!\n\nStart a new round?')) {
      resetRound();
      showScreen('courseSetup');
      // Re-attach course → players flow
      els.nextToPlayers?.addEventListener('click', () => {
        if (currentCourse === null) return alert('Select a course');
        showScreen('playerSetup');
        renderPlayerSelect();
      });
    }
  });

  // === BACK TO SETUP (from summary) ===
  document.getElementById('backToSetup')?.addEventListener('click', () => {
    if (confirm('Leave summary and start over?')) {
      resetRound();
      showScreen('courseSetup');
    }
  });



  // BBB COMP (FINISH ROUND)
  els.completeRound.onclick = () => {
    if (finishedHoles.size !== HOLES) {
      alert(`Finish all ${HOLES} holes first.`);
      return;
    }
    precomputeAllTotals();
    showSummary();
    setTimeout(() => {
      if (confirm('Round complete!\n\nStart a new round?')) {
        resetRound();
        showScreen('courseSetup');
       
  };

  // EXIT ROUND — ONE PROMPT ONLY
  els.exitRound.onclick = () => {
    if (confirm('Exit round and lose all progress?')) {
      resetRound();
      location.reload();
    }
  };

  // DARK MODE TOGGLE
  if (els.darkModeToggle) {
    els.darkModeToggle.onclick = () => {
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      document.documentElement.setAttribute('data-theme', isDark ? 'light' : 'dark');
      localStorage.setItem('bbb_dark', !isDark);
    };
  }

  // HELP BUTTON — OPEN MODAL
  if (els.bbbHelpBtn) {
    els.bbbHelpBtn.onclick = () => {
      document.getElementById('bbbHelpModal')?.classList.remove('hidden');
      document.getElementById('bbbHelpBackdrop')?.classList.remove('hidden');
    };
  }

  // CLOSE HELP MODAL — X button + backdrop click
  const closeHelp = () => {
    document.getElementById('bbbHelpModal')?.classList.add('hidden');
    document.getElementById('bbbHelpBackdrop')?.classList.add('hidden');
  };

  document.getElementById('closeHelp')?.addEventListener('click', closeHelp);
  document.getElementById('bbbHelpBackdrop')?.addEventListener('click', closeHelp);
})
  }  


function attachNavListeners() {
  const add = (id, handler) => {
    const btn = document.getElementById(id);
    if (btn) {
      btn.onclick = null;           // clear old
      btn.onclick = handler;        // attach fresh
    }
  };

  add('prevHole', () => {
    if (currentHole > 1 && !isHoleInProgress) {
      currentHole--;
      updateHole();
      updateCourseInfoBar();
      logScreen(`PREV → HOLE ${currentHole}`);
    }
  });

  add('nextHole', () => {
    if (currentHole < HOLES && !isHoleInProgress) {
      currentHole++;
      updateHole();
      updateCourseInfoBar();
      logScreen(`NEXT → HOLE ${currentHole}`);
    }
  });

  add('editHole', () => {
    if (finishedHoles.has(currentHole)) {
      finishedHoles.delete(currentHole);
      isHoleInProgress = false;
      precomputeAllTotals();
      updateHole();
      logScreen('EDIT MODE');
    }
  });

  add('finishHole', finishCurrentHole);
}


  
  function save() {
    localStorage.setItem('bbb', JSON.stringify({ 
      players: players.map(p => ({ ...p, _cachedTotal: undefined, _cachedHoleTotals: undefined })), 
      currentHole, currentCourse,
      finishedHoles: Array.from(finishedHoles), inRound
    }));
  }

  
  

function renderPlayerSelect() {
  console.log('%cDEBUG: renderPlayerSelect() called', 'color: orange; font-weight: bold');
  console.log('Players:', players.length, 'Roster:', roster.length);

  els.playerSelect.innerHTML = '';
  roster.forEach((p, i) => {
    const div = document.createElement('div');
    div.innerHTML = `<label><input type="checkbox" data-index="${i}" ${players.find(pl => pl.name === p.name) ? 'checked' : ''}> ${p.name}</label>`;
    els.playerSelect.appendChild(div);
  });

  // === GET startGame BUTTON ===
  els.startGame = document.getElementById('startGame');
  if (!els.startGame) {
    console.error('%cFATAL: #startGame NOT FOUND!', 'color: red');
    return;
  }

 // === SHOW BUTTON CONTAINER (FORCE ENTIRE CHAIN) ===
  const container = els.startGame.parentElement;
  container.style.display = 'block';
  els.playerSetup.style.display = 'block';  // Force show parent
  els.playerSetup.classList.remove('hidden');  // Remove hidden class

  // === ATTACH CHECKBOX LISTENERS ===
  els.playerSelect.querySelectorAll('input[type="checkbox"]').forEach(chk => {
    chk.addEventListener('change', () => {
      const idx = parseInt(chk.dataset.index);
      const player = roster[idx];

   if (chk.checked) {
    if (players.length >= MAX_PLAYERS) {
     chk.checked = false;
     alert(`Max ${MAX_PLAYERS} players`);
     return;
    }
    players.push({ ...player, scores: Array(HOLES).fill(null).map(() => ({})), gir: Array(HOLES).fill(false), _cachedTotal: 0, _cachedHoleTotals: {} });
  } else {
  players = players.filter(p => p.name !== player.name);
}

// ADD THIS LINE — keeps table and standings alphabetical
players.sort((a, b) => a.name.localeCompare(b.name));


      els.startGame.disabled = players.length < 2;
      save();
    });
  });


  saveRound();

  // === INITIAL STATE ===
  els.startGame.disabled = players.length < 2;

  // === ATTACH START GAME LISTENER ===
els.startGame.onclick = () => {
  if (players.length < 2) return alert('Select at least 2 players');

  // Get current course index from the dropdown
  const selectedCourseIndex = els.courseSelect.value;
  if (selectedCourseIndex === '' || selectedCourseIndex === null) {
    return alert('Please select a course first');
  }

  currentCourse = Number(selectedCourseIndex);

  // ←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←
  // CRITICAL: Save the course index so resume works perfectly
  // ←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←←
  localStorage.setItem('bbb_currentCourse', currentCourse);

  currentHole = 1;  // ← FORCE HOLE 1
  finishedHoles.clear();
  isHoleInProgress = false;

  players.forEach(p => {
    p.scores = Array(HOLES).fill(null).map(() => ({}));
    p.gir = Array(HOLES).fill(false);
    p._cachedTotal = 0;
    p._cachedHoleTotals = {};
  });

  players.sort((a, b) => a.name.localeCompare(b.name));

  inRound = true;
  saveRound();

  showScreen('game');

 if (window.pm) {
  window.pm.apply();
}

  updateHole();
  attachFinishHoleListener();
  attachNavListeners();
  setupGameButtons();
  updateCourseInfoBar();
  save();

  logScreen('GAME STARTED');
};
}



  function generateParInputs() {
    const container = document.getElementById('pars');
    container.innerHTML = '';
    for (let i = 0; i < HOLES; i++) {
      const label = document.createElement('label');
      label.innerHTML = `Hole ${i+1}: <input type="number" min="3" max="5" value="4" class="par-input" data-hole="${i}">`;
      container.appendChild(label);
    }
  }

  // === CARRY LOGIC ===
 function getCarryInForHole(holeNumber) {
  const carry = { firstOn: 0, closest: 0, putt: 0, greenie: 0 };

  for (let h = 1; h < holeNumber; h++) {
    if (!finishedHoles.has(h)) continue;

    const idx = h - 1;
    const par = courses[currentCourse].pars[idx];
    const isPar3 = par === 3;
    const scores = players.map(p => p.scores[idx]).filter(Boolean);

    // === FIRST ON (only Par 4/5) ===
    if (!isPar3) {
      if (scores.some(s => s.firstOn)) {
        carry.firstOn = 0;  // awarded → reset carry
      } else {
        carry.firstOn++;    // no winner → carry forward
      }
    }

    // === GREENIE (only Par 3) ===
    if (isPar3) {
      if (scores.some(s => s.firstOn)) {  // firstOn = Greenie on Par 3
        carry.greenie = 0;
      } else {
        carry.greenie++;
      }
    }

    // === CLOSEST (all holes) ===
    if (scores.some(s => s.closest)) {
      carry.closest = 0;
    } else {
      carry.closest++;
    }

    // === PUTT (all holes) ===
    if (scores.some(s => s.putt)) {
      carry.putt = 0;
    } else {
      carry.putt++;
    }
  }

  return carry;
}



 function precomputeAllTotals() {
  players.forEach(p => {
    let total = 0;
    p._cachedHoleTotals = {};

    for (let idx = 0; idx < HOLES; idx++) {
      const holeNumber = idx + 1;
      if (!finishedHoles.has(holeNumber)) continue;

      const s = p.scores[idx] || {};
      const carryIn = getCarryInForHole(holeNumber);
      const par = courses[currentCourse].pars[idx];
      const isPar3 = par === 3;

      let holePoints = 0;

      // Base points
      if (s.firstOn) holePoints += 1;
      if (s.closest) holePoints += 1;
      if (s.putt) holePoints += 1;

      // Carry-in
      if (holeNumber < HOLES) {
        if (s.firstOn) {
          holePoints += isPar3 ? carryIn.greenie : carryIn.firstOn;
        }
        if (s.closest) holePoints += carryIn.closest;
        if (s.putt) holePoints += carryIn.putt;
      }

      p._cachedHoleTotals[idx] = holePoints;
      total += holePoints;
    }

    p._cachedTotal = total;
  });
}

  function getRunningTotal(player) {
    let sum = 0;
    for (let h = 1; h <= currentHole; h++) {
      if (finishedHoles.has(h)) {
        sum += player._cachedHoleTotals?.[h - 1] || 0;
      }
    }
    return sum;
  }

function updateHole() {
  console.log('=== UPDATEHOLE DEBUG START ===');
  console.log('currentHole:', currentHole);
  console.log('currentCourse (raw):', currentCourse);
  console.log('typeof currentCourse:', typeof currentCourse);
  console.log('courses array length:', courses.length);
  console.log('courses[currentCourse]:', courses[currentCourse]);
  console.log('courses[0]:', courses[0]);
  console.log('courses[1]:', courses[1]);
  console.log('courses[2]:', courses[2]);
  console.log('=== UPDATEHOLE DEBUG END ===');

  // FINAL SAFETY NET — currentCourse MUST be a valid number
  if (currentCourse === null || currentCourse === undefined || isNaN(Number(currentCourse))) {
    console.log('currentCourse is invalid — FORCING to 0');
    currentCourse = 0;
  } else {
    currentCourse = Number(currentCourse);
  }

  if (!inRound || players.length === 0 || !courses[currentCourse]) return;

  precomputeAllTotals();

  const holeIdx = currentHole - 1;
  const courseObj = courses[currentCourse];
  if (!courseObj || !courseObj.pars) return;

  const par = courseObj.pars[holeIdx];
  const isPar3 = par === 3;
  const courseName = courseObj.name || 'Unknown';

  els.holeDisplay.innerHTML = `<strong>${courseName}</strong> • Hole ${currentHole} (Par ${par}) • ${finishedHoles.size} finished`;
  els.firstOnHeader.textContent = isPar3 ? 'GR' : 'FO';

  const isFinished = finishedHoles.has(currentHole);
  const finishBtn = document.getElementById('finishHole');
  const editBtn = document.getElementById('editHole');
  if (finishBtn) finishBtn.classList.toggle('hidden', isFinished);
  if (editBtn) editBtn.classList.toggle('hidden', !isFinished);

  const carryIn = getCarryInForHole(currentHole);
  renderTable(carryIn, isFinished);
  renderHoleSummary();
  renderRoundSummary();
  updateCourseInfoBar();
  updateNavButtons();
  attachNavListeners();
  save();
  if (debugMode) renderDebugCarryTable();

  // FINAL FIX — FORCES FULL SCREEN REPAINT ON iOS/PC AFTER RESUME
  console.log('updateHole() END — about to repaint');
  const table = document.querySelector('#scoreTable');
  if (table) {
    console.log('Table found — forcing repaint');
    table.style.display = 'none';
    void table.offsetHeight;
    table.style.display = '';
  } else {
    console.log('TABLE NOT FOUND IN DOM');
  }
}
 
  function updateCourseInfoBar() {
  if (!inRound || currentCourse === null || currentCourse === undefined) {
    els.courseInfoBar.style.display = 'none';
    return;
  }

  // FORCE currentCourse to be a number
  const courseIndex = Number(currentCourse);
  if (isNaN(courseIndex) || !courses[courseIndex]) {
    els.courseInfoBar.style.display = 'none';
    return;
  }

  const course = courses[courseIndex];
  if (!course.pars || course.pars[currentHole - 1] === undefined) {
    els.courseInfoBar.style.display = 'none';
    return;
  }

  els.infoCourseName.textContent = course.name;
  els.infoCurrentHole.textContent = currentHole;
  els.infoPar.textContent = `Par ${course.pars[currentHole - 1]}`;
  els.courseInfoBar.style.display = 'block';
}



  function renderTable(carryIn, isFinished) {
    if (!els.scoreTable || !els.scoreTable.tBodies || !els.scoreTable.tBodies[0]) return;
    const tbody = els.scoreTable.tBodies[0];
    tbody.innerHTML = '';

    const holeIdx = currentHole - 1;
    const par = courses[currentCourse].pars[holeIdx];
    const isPar3 = par === 3;

    players.forEach(p => {
      const s = p.scores[holeIdx] || {};
      const row = tbody.insertRow();

      row.insertCell().textContent = p.name;
      row.cells[0].className = 'player-name';

      const createCheckbox = (point) => {
        const cell = row.insertCell();
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = !!s[point];
        input.disabled = isFinished;
        input.onclick = (e) => {
           e.preventDefault(); // Stop double-tap zoom on iOS
           toggleScore(p, holeIdx, point);
    };
        cell.appendChild(input);
      };

      createCheckbox('firstOn');
      createCheckbox('closest');
      createCheckbox('putt');

      const holeCell = row.insertCell();
if (isFinished) {
  const s = p.scores[holeIdx] || {};
  const counts = { FO: 0, GR: 0, CL: 0, P: 0 };

  // Base win on this hole (always 1 if won)
  if (s.firstOn) counts[isPar3 ? 'GR' : 'FO'] += 1;
  if (s.closest) counts.CL += 1;
  if (s.putt) counts.P += 1;

  // Add carries
  if (s.firstOn) counts[isPar3 ? 'GR' : 'FO'] += (isPar3 ? carryIn.greenie : carryIn.firstOn);
  if (s.closest) counts.CL += carryIn.closest;
  if (s.putt) counts.P += carryIn.putt;

  const totalPts = p._cachedHoleTotals?.[holeIdx] || 0;

  // Build label like "6GR" "3P" "2FO•CL"
  const parts = [];
  if (counts.GR > 0) parts.push(`${counts.GR}GR`);
  if (counts.FO > 0) parts.push(`${counts.FO}FO`);
  if (counts.CL > 0) parts.push(`${counts.CL}CL`);
  if (counts.P  > 0) parts.push(`${counts.P}P`);

  const labelText = parts.length > 0 ? parts.join(' • ') : '—';

  holeCell.innerHTML = `
    <div style="font-size:0.85rem;line-height:1.3;text-align:center;">
      <strong style="font-size:1.1em;">${totalPts}</strong><br>
      <small style="color:#888;">${labelText}</small>
    </div>
  `;
} else {
  holeCell.textContent = '—';
  holeCell.style.color = '#666';
}

      const runCell = row.insertCell();
      runCell.textContent = getRunningTotal(p);
      runCell.style.fontWeight = '600';
      runCell.style.color = '#0a0';

      const totalCell = row.insertCell();
      totalCell.textContent = p._cachedTotal || 0;
      totalCell.style.fontWeight = '600';
    });
  }
 
   
function renderRoundSummary() {
  if (!els.roundSummary) return;

  let wins = 0;
  players.forEach(p => wins += p._cachedTotal || 0);

  const expected = finishedHoles.size * 3;
  const openCarry = expected - wins;   // ← correct variable name

  els.roundSummary.innerHTML = `
    <div style="font-size:0.9rem;line-height:1.4;">
      Wins: <strong>${wins}</strong> + Open Carry: <strong>${openCarry}</strong> = <strong>${expected}</strong><br>
      <small>Expected Pts: ${finishedHoles.size} Holes × 3 = ${expected}</small>
    </div>
  `;

  els.roundSummary.classList.remove('hidden');
}

function renderHoleSummary() {
  if (!els.holeSummary) return;

  // Always calculate fresh carry-in for the hole we are currently looking at
  const carryIn = getCarryInForHole(currentHole);

  const parts = [];
  if (carryIn.firstOn)  parts.push(`FO: +${carryIn.firstOn}`);
  if (carryIn.closest) parts.push(`CL: +${carryIn.closest}`);
  if (carryIn.putt)     parts.push(`P: +${carryIn.putt}`);
  if (carryIn.greenie)  parts.push(`GR: +${carryIn.greenie}`);

  let text = '';
  if (parts.length > 0) {
    text = `<strong>Available Carry:</strong> ${parts.join(' • ')}`;
  } else if (finishedHoles.has(currentHole)) {
    const nextCarry = getCarryInForHole(currentHole + 1);
    const totalOpen = nextCarry.firstOn + nextCarry.closest + nextCarry.putt + nextCarry.greenie;
    text = totalOpen > 0 ? `<strong>Open Carry:</strong> ${totalOpen}` : `<strong>Open Carry: 0</strong>`;
  } else {
    text = `<strong>Open Carry: 0</strong>`;
  }

  els.holeSummary.innerHTML = `<div class="summary-carry-in">${text}</div>`;
}


    function toggleScore(player, holeIdx, point) {
    const currentHoleIdx = currentHole - 1;
    if (holeIdx === currentHoleIdx && !isHoleInProgress) {
      const hasAnyScore = players.some(p => {
        const s = p.scores[holeIdx] || {};
        return s.firstOn || s.closest || s.putt;
      });
      if (!hasAnyScore) {
      isHoleInProgress = true;   // ← this + updateNavButtons() is enough
      updateNavButtons();        // ← call it directly
    }
    }

    const score = player.scores[holeIdx];
    const wasChecked = !!score[point];
    const willBeChecked = !wasChecked;

    if (willBeChecked) {
      const otherHasIt = players.some((p, j) => {
        return j !== players.indexOf(player) && p.scores[holeIdx] && p.scores[holeIdx][point];
      });
      if (otherHasIt) {
        alert('Only one winner per point!');
        return;
      }
    }

    score[point] = willBeChecked;
    save();
    precomputeAllTotals();
    updateHole();
  }

  function finishCurrentHole() {
  finishedHoles.add(currentHole);
  isHoleInProgress = false;

  precomputeAllTotals();
  updateHole();
  logScreen('FINISHED HOLE ' + currentHole);

 // WALT SHADOW TEXT — 100% STEALTH VIA SERVER (NO POPUP EVER)
if (!practiceMode && ENABLE_WALT_SHADOW_TEXT && waltShadowPhone && finishedHoles.has(currentHole)) {
  const holeIdx = currentHole - 1;
  const par = courses[currentCourse].pars[holeIdx];
  const isPar3 = par === 3;
  let message = `BBB - H${currentHole} (P${par})\n\n`;

  players.forEach(p => {
    const s = p.scores[holeIdx] || {};
    const pts = p._cachedHoleTotals?.[holeIdx] || 0;
    const notes = [];
    if (s.firstOn) notes.push(isPar3 ? 'GR' : 'FO');
    if (s.closest) notes.push('CL');
    if (s.putt) notes.push('P');
    message += `${p.name}: ${pts}${notes.length ? ` (${notes.join('/')})` : ''} | Run: ${getRunningTotal(p)}\n`;
  });

  // DETAILED CARRY BREAKDOWN
  const carryOut = getCarryInForHole(currentHole + 1);
  const carryParts = [];
  if (carryOut.firstOn) carryParts.push(`FO: ${carryOut.firstOn}`);
  if (carryOut.closest) carryParts.push(`CL: ${carryOut.closest}`);
  if (carryOut.putt) carryParts.push(`P: ${carryOut.putt}`);
  if (carryOut.greenie) carryParts.push(`GR: ${carryOut.greenie}`);
  const carryText = carryParts.length > 0 ? carryParts.join(' • ') : '0';
  message += `\nCarry: ${carryText}\n\nStandings:\n`;

  const standings = players
    .map(p => ({ name: p.name, total: p._cachedTotal || 0 }))
    .sort((a, b) => b.total - a.total);

  standings.forEach((p, i) => {
    message += `${i + 1}. ${p.name}: ${p.total}\n`;
  });

  const shadowMessage = "LIVE BBB (Walt shadow)\n\n" + message;

  /* // 1. SEND SMS (opens Messages app)
  setTimeout(() => {
    window.location.href = `sms:${waltShadowPhone}?body=${encodeURIComponent(shadowMessage)}`;
  }, 1200); */

  // 2. SEND TO SERVER (silent backup — never fails the app)
  fetch('https://pwa-players-backend.onrender.com/send-walt', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ message: shadowMessage })
  }).catch(err => console.error('Walt shadow send failed:', err));
}

// Auto-pulse BBB COMP when last hole is finished
  if (currentHole === HOLES && finishedHoles.size === HOLES) {
    setTimeout(() => {
      const btn = document.getElementById('completeRound');
      if (btn && !btn.classList.contains('pulsing')) {
        btn.classList.add('pulsing');
        btn.textContent = 'BBB COMP (READY!)';
        btn.title = 'Tap to view final leaderboard';
      }
    }, 400);
  }

saveRound();
}


  function simulateRound() {
    if (inRound) {
      if (!confirm('End current round and start simulation?')) return;
      resetRound();
    }

    if (courses.length === 0) {
      alert('No courses found!');
      return;
    }
    currentCourse = 0;
    localStorage.setItem('bbb_currentCourse', currentCourse);

    if (roster.length < 2) {
      alert('Need at least 2 players in roster!');
      return;
    }
    players = roster.slice(0, 4).map(p => ({
      ...p,
      scores: Array(HOLES).fill(null).map(() => ({})),
      gir: Array(HOLES).fill(false),
      _cachedTotal: 0,
      _cachedHoleTotals: {}
    }));

    currentHole = 1;
    finishedHoles.clear();
    inRound = true;

    const names = players.map(p => p.name);
    const binomialSuccess = (p) => Math.random() < p;

    for (let h = 1; h <= HOLES; h++) {
      currentHole = h;
      const holeIdx = h - 1;
      const par = courses[currentCourse].pars[holeIdx];

      const firstOnWinner = binomialSuccess(0.90) ? names[Math.floor(Math.random() * names.length)] : null;
      const closestWinner = binomialSuccess(0.99) ? names[Math.floor(Math.random() * names.length)] : null;
      const puttWinner = binomialSuccess(0.80) ? names[Math.floor(Math.random() * names.length)] : null;

      if (firstOnWinner) players.find(p => p.name === firstOnWinner).scores[holeIdx].firstOn = true;
      if (closestWinner) players.find(p => p.name === closestWinner).scores[holeIdx].closest = true;
      if (puttWinner) players.find(p => p.name === puttWinner).scores[holeIdx].putt = true;

      finishedHoles.add(h);
    }

    precomputeAllTotals();
    updateHole();
    save();

    const playerTotal = players.reduce((sum, p) => sum + p._cachedTotal, 0);
    const carry = getCarryInForHole(HOLES + 1);
    const totalCarry = carry.firstOn + carry.closest + carry.putt + carry.greenie;

    els.simResult.innerHTML = `
      <div style="margin:1rem 0;padding:1rem;background:#e6f7e6;border-radius:8px;font-weight:600;color:#155724;">
        SIMULATION SUCCESSFUL!<br>
        18 holes • 54 total points<br>
        Players: ${playerTotal} • Carry: ${totalCarry}<br>
        <small style="color:#0a0">
          VALIDATED: ${playerTotal} + ${totalCarry} = 54<br>
          ${playerTotal === 54 && totalCarry === 0 ? 'All points awarded!' : 'ERROR'}
        </small>
      </div>
    `;

    logScreen('SIMULATION COMPLETE');
  }

  

  function showSummary() {
    showScreen('summary');
    const totals = players.map(p => ({ name: p.name, points: p._cachedTotal || 0 }));
    totals.sort((a,b) => b.points - a.points);
    els.leaderboard.innerHTML = '';
    totals.forEach(t => {
      const li = document.createElement('li');
      li.textContent = `${t.name}: ${t.points} pts`;
      els.leaderboard.appendChild(li);
    });
    
  }

 els.completeRound.addEventListener('click', () => {
  if (finishedHoles.size !== HOLES) {
    alert(`Finish all ${HOLES} holes first.`);
    return;
  }

  precomputeAllTotals();

  // 1. Show the nice leaderboard screen first
  showSummary();

  // 2. Auto-email the CSV to you (Walt)
  // emailRoundToWalt();

  // 3. Optional: give them a second to read it, then offer New Round
  setTimeout(() => {
  if (confirm('Round complete – summary emailed to Walt!\n\nStart a new round?')) {
    resetRound();
    showScreen('courseSetup');

    // RE-ATTACH THE "Load Course →" BUTTON — THIS FIXES THE LOOP
    els.nextToPlayers?.addEventListener('click', () => {
      if (currentCourse === null || currentCourse === undefined) {
        return alert('Please select a course first');
      }
       showScreen('playerSetup');
      renderPlayerSelect();
      logScreen('PLAYER SETUP');
    });
  }
}, 500);
});

  els.exitRound.addEventListener('click', () => {
    if (confirm('Exit without saving?')) {
      resetRound();
      /* els.historyBtn.disabled = false; */
      location.reload();
    }
  });

 

  function resetRound() {
  localStorage.removeItem('bbb');
  inRound = false;
  players = [];
  currentCourse = null;
  currentHole = 1;
  finishedHoles.clear();

  // === RESET BBB COMP BUTTON ===
  const compBtn = document.getElementById('completeRound');
  if (compBtn) {
    compBtn.classList.remove('pulsing');
    compBtn.textContent = 'BBB COMP';
    compBtn.title = 'Finish round';
  }
}

  

   

 
function attachFinishHoleListener() {
  const btn = document.getElementById('finishHole');
  if (!btn) return;
  btn.onclick = null; // clear any old listener
  btn.onclick = finishCurrentHole; // direct assignment — never fails
}
  // DEBUG 

  let debugMode = false;
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.shiftKey && e.key === 'D') {
      debugMode = !debugMode;
      els.debugPanel.classList.toggle('hidden', !debugMode);
      if (debugMode) updateDebugPanel();
    }
    if (e.keyCode === 113) {
      e.preventDefault();
      if (confirm('Run full 18-hole simulation?')) {
        simulateRound();
      }
    }
  });
  els.closeDebug.addEventListener('click', () => {
    debugMode = false;
    els.debugPanel.classList.add('hidden');
  });

  function updateDebugPanel() {
    els.debugOutput.innerHTML = '';
    renderDebugCarryTable();
    const hint = document.createElement('div');
    hint.style.marginTop = '1rem'; hint.style.padding = '0.5rem'; hint.style.background = '#333';
    hint.style.borderRadius = '6px'; hint.style.fontSize = '0.8rem'; hint.style.color = '#0f0';
    hint.innerHTML = '<strong>F2</strong> = Run Simulation (PC only)';
    els.debugOutput.appendChild(hint);
  }


// === DOM READY ===  DOMContentLoaded ===
document.addEventListener('DOMContentLoaded', async () => {
  console.log('DOM ready — initializing app');

  els = {
    courseSetup: document.getElementById('courseSetup'),
    playerSetup: document.getElementById('playerSetup'),
    game: document.getElementById('game'),
    summary: document.getElementById('summary'),
    darkModeToggle: document.getElementById('darkModeToggle'),
    bbbHelpBtn: document.getElementById('bbbHelpBtn'),
    courseSelect: document.getElementById('courseSelect'),
    nextToPlayers: document.getElementById('nextToPlayers'),
    playerSelect: document.getElementById('playerSelect'),
    startGame: document.getElementById('startGame'),
    holeDisplay: document.getElementById('holeDisplay'),
    prevHole: document.getElementById('prevHole'),
    nextHole: document.getElementById('nextHole'),
    finishHole: document.getElementById('finishHole'),
    editHole: document.getElementById('editHole'),
    firstOnHeader: document.getElementById('firstOnHeader'),
    scoreTable: document.getElementById('scoreTable'),
    holeSummary: document.querySelector('.holeSummary'),
    roundSummary: document.getElementById('roundSummary'),
    sendSMS: document.getElementById('sendSMS'),
    completeRound: document.getElementById('completeRound'),
    exitRound: document.getElementById('exitRound'),
    leaderboard: document.getElementById('leaderboard'),
    courseInfoBar: document.getElementById('courseInfoBar'),
    infoCourseName: document.getElementById('infoCourseName'),
    infoCurrentHole: document.getElementById('infoCurrentHole'),
    infoPar: document.getElementById('infoPar'),
    debugPanel: document.getElementById('debugPanel'),
    debugOutput: document.getElementById('debugOutput'),
    closeDebug: document.getElementById('closeDebug'),
    simResult: document.getElementById('simResult')
  };

  // === LOAD DATA + SHOW COURSE PICKER ===
  await loadDataFromBackend();
  showScreen('courseSetup');

  // === NEXT → PLAYERS BUTTON ===
  els.nextToPlayers?.addEventListener('click', () => {
    if (!currentCourse) return alert('Please select a course first');
    showScreen('playerSetup');
    renderPlayerSelect();
    logScreen('PLAYER SETUP');
  });

  // === BACK TO COURSE FROM PLAYER SETUP ===
  document.getElementById('backToCourse')?.addEventListener('click', () => {
    showScreen('courseSetup');
    logScreen('BACK TO COURSE SELECT');
  });

  // === RESUME SAVED ROUND ===
  const savedRounds = [];
  for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    if (key?.startsWith('bbb_round_BBB-')) {
      try {
        const data = JSON.parse(localStorage.getItem(key));
        savedRounds.push({ ...data, key });
      } catch (e) {}
    }
  }

  if (savedRounds.length > 0) {
    savedRounds.sort((a, b) => new Date(b.date) - new Date(a.date));

    let message = `You have ${savedRounds.length} active BBB round(s):\n\n`;
    savedRounds.forEach((r, i) => {
      message += `${i + 1}. ${r.courseName || 'Unknown Course'}\n`;
      message += `    Hole ${r.currentHole} • ${r.players.map(p => p.name).join(', ')}\n`;
      message += `    ${new Date(r.date).toLocaleDateString()}`;
      message += ` (${r.practiceMode ? 'Practice' : 'Live'} Round)\n\n`;
    });
    message += `Enter the number of the round you want to resume\n(or Cancel to start a new one):`;

    const choice = prompt(message);

    if (choice && !isNaN(choice) && choice >= 1 && choice <= savedRounds.length) {
      const selected = savedRounds[choice - 1];

      players = selected.players.map(p => ({
        ...p,
        scores: Array(18).fill(null).map(() => ({})),
        _cachedTotal: selected._cachedTotals?.[p.name] || 0
      }));
      Object.keys(selected.scores || {}).forEach(name => {
        const p = players.find(x => x.name === name);
        if (p) p.scores = selected.scores[name];
      });

      currentHole = selected.currentHole;
      currentCourse = selected.currentCourseIndex || courses.findIndex(c => c.name === selected.courseName);
      if (currentCourse === -1) currentCourse = 0;
      finishedHoles = new Set(selected.finishedHoles || []);
      inRound = true;
      practiceMode = selected.practiceMode || false;

      showScreen('game');
      updateHole();
      if (window.pm) window.pm.apply();
      requestWakeLock();  // ← MOVED HERE
      return;
    }
  }

  // === WAKE LOCK (ONLY WHEN ROUND STARTS) ===
  let wakeLock = null;
  async function requestWakeLock() {
    if ('wakeLock' in navigator && inRound) {
      try {
        wakeLock = await navigator.wakeLock.request('screen');
        console.log('Wake Lock active');
      } catch (err) {
        console.log('Wake Lock failed', err);
      }
    }
  }

  // Call in startGame and resume
  // (already in startGame.onclick and resume above)

  // === PRACTICE MODE IIFE ===
  (function () {
    'use strict';
    const banner = document.getElementById('practiceBanner');
    const toggle = document.getElementById('practiceToggle');
    const body = document.body;

    if (!banner || !toggle) return;

    practiceMode = localStorage.getItem('bbb_practiceMode') === 'true';

    function apply() {
      banner.classList.toggle('hidden', !practiceMode);
      toggle.checked = practiceMode;
      body.classList.toggle('practice-mode', practiceMode);
      localStorage.setItem('bbb_practiceMode', practiceMode);
    }

    apply();

    toggle.addEventListener('change', () => {
      practiceMode = toggle.checked;
      apply();
      if (inRound) saveRound();
    });

    window.pm = { practiceMode, apply };
  })();
});




</script>

 <!-- COURSE SETUP – BACKEND-DRIVEN (FINAL) -->
<section id="courseSetup" class="card center-block">
  <h2 style="text-align:center; color:var(--green); margin:1rem 0 0.5rem; font-size:1.6rem;">
    BBB Golf
  </h2>

  <div id="courseLoader" style="text-align:center; padding:2rem 1rem;">
    <div style="font-size:1rem; color:#666; margin-bottom:1rem;">Loading your courses...</div>
    <div style="width:48px; height:48px; border:5px solid #f0f0f0; border-top:5px solid var(--green); border-radius:50%; animation:spin 1s linear infinite; margin:0 auto;"></div>
  </div>

  <div id="courseError" class="hidden" style="text-align:center; padding:1.5rem; color:#a00;">
    <p>Failed to load data from server.</p>
    <button id="retryBtn" style="background:var(--btn-bg); color:var(--btn-text); padding:0.8rem 1.6rem; font-size:1rem; margin:0.5rem;">
      Retry
    </button>
    <p style="font-size:0.9rem; color:#666; margin-top:1rem;">
      Check internet or wake the backend (it may be sleeping).
    </p>
  </div>

  <div id="coursePicker" class="hidden">
    <select id="courseSelect" style="width:100%; padding:0.9rem; font-size:1.2rem; margin-bottom:1rem; border-radius:8px; border:1px solid #aaa;">
      <option value="">– Select Course –</option>
    </select>
    <button id="nextToPlayers" disabled style="width:100%; padding:1.1rem; font-size:1.3rem; font-weight:bold;">
      Load Course →
    </button>
  </div>

  
</section>

 
  <!-- PLAYER SETUP -->
  <section id="playerSetup" class="card hidden center-block" role="region" aria-labelledby="playerSetupTitle">
    <h2 id="playerSetupTitle" class="hidden">Player Setup</h2>
    <button id="backToCourse">Back</button>
    <div id="playerSelect"></div>
    <div style="margin-top: 1rem; text-align: center;">
      <button id="startGame" disabled style="width: 100%; padding: 1rem; font-size: 1.1rem;">Start Round</button>
    </div>
  </section>

  <!-- ROSTER -->
  <section id="roster" class="card hidden center-block" role="region" aria-labelledby="rosterTitle">
    <h2 id="rosterTitle" class="hidden">Roster</h2>
    <button id="backToCourseFromRoster">Back</button>
    <input id="rosterName" placeholder="Name" style="width:100%;margin:0.5rem 0;" />
    <input id="rosterPhone" placeholder="Phone" style="width:100%;margin:0.5rem 0;" />
    <input id="rosterEmail" placeholder="Email" style="width:100%;margin:0.5rem 0;" />
    <button id="addToRoster">Add</button>
    <div id="rosterList"></div>
  </section>

  <!-- COURSE FORM -->
  <section id="courseForm" class="card hidden center-block" role="region" aria-labelledby="courseFormTitle">
    <h2 id="courseFormTitle" class="hidden">Add Course</h2>
    <button id="cancelCourse">Cancel</button>
    <input id="courseName" placeholder="Course Name" style="width:100%;margin:0.5rem 0;" />
    <div id="pars"></div>
    <button id="saveCourse">Save Course</button>
  </section>

  <!-- GAME SCREEN -->
  <section id="game" class="card hidden center-block" role="region" aria-labelledby="gameTitle">
    <h2 id="gameTitle" class="hidden">Game</h2>
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;flex-wrap:wrap;">
      <h3 id="holeDisplay"></h3>
      <div>
        <button id="prevHole">Prev</button>
        <button id="nextHole">Next</button>
        <button id="editHole" class="hidden">Edit</button>
        <button id="finishHole">Finish Hole</button>
      </div>
    </div>

    <table id="scoreTable">
      <thead>
        <tr>
          <th>Player</th>
          <th id="firstOnHeader">FO</th>
          <th>CL</th>
          <th>P</th>
          <th>H</th>
          <th>RUN</th>
          <th>TOT</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <div class="holeSummary"></div>
    <div id="roundSummary" class="hidden"></div>

   <div class="control-bar">
  <button id="sendSMS" title="Send live update to group">SMS</button>
  <button id="completeRound" title="Finish round & email Walt">BBB COMP</button>
  <button id="exitRound" title="Quit without saving">EXIT</button>
  <button id="darkModeToggle" title="Toggle dark mode">DARK</button>
  <button id="bbbHelpBtn" title="Open BBB Golf Help" style="margin-left:auto;">
    HELP
  </button>
</div>
  
  </section>

  <!-- SUMMARY -->
<section id="summary" class="card hidden center-block" role="region" aria-labelledby="summaryTitle">
  <h2 id="summaryTitle" class="hidden">Summary</h2>

  <!-- BIG GREEN CALL-TO-ACTION -->
  <div style="text-align:center; margin:1.5rem 0;">
    <button id="finalBBBComp" style="
      background:#0a0; color:#000; font-weight:bold; font-size:1.3rem;
      padding:1rem 2rem; border-radius:12px; width:90%; max-width:400px;
    ">
      BBB COMP – Round Complete!
    </button>
  </div>

  <!-- Smaller back button -->
  <button id="backToSetup" style="margin-top:0.5rem; opacity:0.7; font-size:0.9rem;">
    ← Back to Setup
  </button>

  <h3 style="margin-top:1.5rem;">Final Leaderboard</h3>
  <ol id="leaderboard"></ol>
</section>

  

  <!-- DEBUG -->
  <div id="debugPanel" class="card hidden" style="position:fixed;bottom:10px;right:10px;width:300px;max-height:80vh;overflow:auto;z-index:1000;">
    <button id="closeDebug" style="float:right;">Close</button>
    <h4>Carry Debug</h4>
    <div id="debugOutput"></div>
  </div>

  <div id="simResult"></div>

  </script> 

  <!-- COURSE + HOLE INFO BAR -->
  <div id="courseInfoBar" class="card center-block" style="margin: 0.5rem auto; padding: 0.75rem; font-size: 0.95rem; text-align: center; background: var(--card); border-radius: 8px; box-shadow: 0 1px 4px rgba(0,0,0,0.1); display: none;">
    <strong id="infoCourseName"></strong> — 
    Hole <span id="infoCurrentHole"></span> of 18
    <span id="infoPar" style="margin-left: 0.5rem; color: #0a6b0a;"></span>
  </div>

    <!-- BBB HELP MODAL -->
  <div id="bbbHelpModal" class="card hidden" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:90%;max-width:400px;z-index:9999;max-height:80vh;overflow:auto;background:var(--card);border-radius:12px;box-shadow:0 4px 20px rgba(0,0,0,0.3);padding-top:env(safe-area-inset-top, 0px);">
    <div style="text-align:center;padding:0.75rem;border-bottom:1px solid #ddd;position:relative;">
      <h3 id="helpModalTitle" style="margin:0;color:var(--green);font-size:1.1rem;">BBB Help</h3>
      <button id="closeHelp" type="button" aria-label="Close help" style="position:absolute;top:8px;right:8px;background:none;border:none;font-size:1.4rem;cursor:pointer;color:var(--text);">×</button>
    </div>
    <div style="padding:1rem;display:grid;gap:1.5rem;font-size:0.9rem;">

      <!-- CONTROL BAR -->
      <div style="font-weight:bold;color:var(--green);margin-bottom:0.5rem;">Control Bar</div>
      <div>SMS – Send live update to the group</div>
      <div>BBB COMP – Complete the round</div>
      <div>EXIT – Quit current round</div>
      <div>DARK – Toggle dark mode</div>
      <div>HELP – You are here :</div>

      <!-- SCORE TABLE -->
      <hr style="margin:1rem 0;border:0;border-top:1px solid #ddd;">
      <div style="font-weight:bold;color:var(--green);margin-bottom:0.5rem;">Score Table</div>
      <div style="display:flex;align-items:center;gap:1.5rem;">
        <span style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:0.8rem;color:#000;background:#0f0;border-radius:4px;">FO</span>
        <div><strong>FO</strong> – First On</div>
      </div>
      <div style="display:flex;align-items:center;gap:1.5rem;">
        <span style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:0.8rem;color:#000;background:#0f0;border-radius:4px;">CL</span>
        <div><strong>CL</strong> – Closest to pin</div>
      </div>
      <div style="display:flex;align-items:center;gap:1.5rem;">
        <span style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:0.8rem;color:#000;background:#0f0;border-radius:4px;">P</span>
        <div><strong>P</strong> – Putts</div>
      </div>
      <div style="display:flex;align-items:center;gap:1.5rem;">
        <span style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:0.8rem;color:#000;background:#0f0;border-radius:4px;">H</span>
        <div><strong>H</strong> – Points this hole</div>
      </div>
      <div style="display:flex;align-items:center;gap:1.5rem;">
        <span style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:0.8rem;color:#000;background:#0f0;border-radius:4px;">RUN</span>
        <div><strong>RUN</strong> – Running total</div>
      </div>
      <div style="display:flex;align-items:center;gap:1.5rem;">
        <span style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:0.8rem;color:#000;background:#0f0;border-radius:4px;">TOT</span>
        <div><strong>TOT</strong> – Final total</div>
      </div>

    </div>
  </div> 

  <!-- BACKDROP -->
  <div id="bbbHelpBackdrop" class="hidden" style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:9998;" aria-hidden="true"></div>


 <!-- SERVICE WORKER — DISABLED FOR RELIABLE iOS HOME SCREEN SHORTCUT
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/bbb-scorer/sw.js')  // ← absolute path (works on Cloudflare too)
        .then(reg => {
          console.log('Service worker registered!', reg);

          // ←←← THIS IS THE FIX — forces update check on every page load
          reg.update();

          // Optional but very nice: auto-reload the page the moment a new version is ready
          reg.addEventListener('updatefound', () => {
            const newWorker = reg.installing;
            if (newWorker) {
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // New version ready → refresh once so user gets it immediately
                  window.location.reload();
                }
              });
            }
          });
        })
        .catch(err => console.error('SW registration failed:', err));
    });
  }
</script>  -->

<!-- TRIGGER BUILD: Practice Mode Live -->

 
 </body>
</html>