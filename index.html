<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>BBB Golf</title>
  <link rel="manifest" href="manifest.json?v=20251123-YOU-WIN" />
  <link rel="icon" href="icon.png" /> 
  <meta id="cacheBuster" name="version" content="20251123-Absolute-Victory">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <style>
    /* === GLOBAL: NO TOP GAP + SAFE PADDING === */
 /* Enable full scroll + safe area    Extra space added here */
html, body {
  margin: 0;
  padding: 0;
  height: 100vh;
  overflow-y: auto;
  overflow-x: hidden;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  scroll-padding-top: env(safe-area-inset-top, 0px);
  -webkit-overflow-scrolling: touch;
}

body {
  position: static;
  overscroll-behavior-y: contain;
  padding-top: env(safe-area-inset-top, 0px);
}


    :root {
      --bg: #f4f4f4;
      --card: #fff;
      --text: #222;
      --green: #0f0;
      --btn-bg: #0f0;
      --btn-text: #000;
      --table-header: #555;
      --table-bg: #eee;
    }
    [data-theme="dark"] {
      --bg: #111;
      --card: #222;
      --text: #eee;
      --green: #0f0;
      --btn-bg: #0f0;
      --btn-text: #000;
      --table-header: #444;
      --table-bg: #333;
    }

    * { box-sizing: border-box; }

    body {
  background: var(--bg);
  color: var(--text);
  line-height: 1.5;
  margin: 0;
  padding: 0;
  min-height: 100vh;
  scroll-padding-top: env(safe-area-inset-top, 0px);
  -webkit-overflow-scrolling: touch;
}

    .card {
  background: var(--card);
  padding: 1rem;
  border-radius: 12px;
  margin: 0 auto 1rem;
  max-width: 800px;
  width: 100%;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

/* FIX EMPTY SPACE ON MOBILE ‚Äî PLAYER SETUP & GAME SCREEN */
#playerSetup,
#game {
  padding-top: 0.3rem !important;
  min-height: auto !important;
}

#playerSetup > div,
#game > div:first-child {
  margin-top: 0.2rem !important;
}




    #courseSetup, #playerSetup, #game, #summary {
      display: flex;
      flex-direction: column;
    }

    h1 { 
      color: var(--green); 
      text-align: center; 
      margin: 0.5rem 0; 
      font-size: 1.4rem; 
    }

    button {
      background: var(--btn-bg);
      color: var(--btn-text);
      border: none;
      padding: 0.75rem 1rem;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      margin: 0.25rem;
    }
    button:disabled { opacity: 0.4; cursor: not-allowed; }

    
    .hidden {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }

    .center-block { 
      max-width: 800px; 
      margin: 0 auto; 
      width: 100%; 
    }

    #holeDisplay {
      font-size: 1.1rem;
      font-weight: 600;
      text-align: center;
      margin: 0.5rem 0;
    }

    #scoreTable { 
      width: 100%; 
      max-width: 800px; 
      margin: 0.5rem auto; 
      border-collapse: collapse; 
    }
    #scoreTable th, #scoreTable td { 
      padding: 0.75rem; 
      text-align: center; 
      border-bottom: 1px solid #ddd; 
    }
    #scoreTable th { 
      background: var(--table-header); 
      color: #fff; 
      font-weight: 600; 
    }
    #scoreTable th:first-child, #scoreTable td:first-child { text-align: left; }
    tbody tr:nth-child(even) { background: var(--table-bg); }

    /* === CHECKBOXES: FINAL VERSION (NO DUPLICATES) === */
    input[type="checkbox"] {
      width: 28px;
      height: 28px;
      transform: scale(1.6);
      margin: 0 6px;
      cursor: pointer;
    }

  

 /* GROK: Final game screen spacing ‚Äî tight top, comfy bottom */
#game {
  padding: 0.4rem 0 1.5rem 0 !important;  /* Top reduced, bottom preserved for control bar */
}



    /* === COURSE SETUP (ONLY ONCE) === */
    #courseSetup {
      padding: 1rem !important;
      display: flex !important;
      flex-direction: column !important;
      align-items: stretch !important;
    }
    #courseSetup > div {
      display: flex !important;
      flex-direction: column !important;
      gap: 0.5rem !important;
      align-items: center !important;
    }
    #courseSelect, #addCourse, #nextToPlayers {
      width: 100% !important;
      max-width: none !important;
      font-size: 1rem !important;
      padding: 0.75rem !important;
    }
    #nextToPlayers:disabled {
      opacity: 0.4 !important;
      background: #ccc !important;
      cursor: not-allowed !important;
    }

    /* PLAYER SETUP & START ROUND */
    #playerSetup {
      padding: 1rem 1rem 160px 1rem !important;
      overflow: visible !important;
    }

    #playerSetup > div[style*="margin-top: 1rem"] {
      margin-top: 1.5rem !important;
      padding: 0.5rem !important;
      background: var(--card) !important;
      border-radius: 8px !important;
      display: block !important;
      width: 100% !important;
      box-sizing: border-box !important;
    }

    #startGame {
      width: 100% !important;
      max-width: none !important;
      padding: 1.2rem !important;
      font-size: 1.2rem !important;
      min-height: 60px !important;
      background: var(--btn-bg) !important;
      color: var(--btn-text) !important;
      border: none !important;
      border-radius: 12px !important;
      font-weight: bold !important;
      cursor: pointer !important;
      box-sizing: border-box !important;
    }
    #startGame:disabled {
      opacity: 0.6 !important;
      background: #ccc !important;
      color: #999 !important;
      cursor: not-allowed !important;
    }

    .holeSummary,
#roundSummary {
  margin: 0.4rem auto !important;
  padding: 0.4rem !important;
  line-height: 1.3 !important;
  font-size: 0.88rem !important;   /* ‚Üê was 0.82rem ‚Äî now matches round summary */
  font-weight: 600 !important;
  text-align: center;
  background: #fff !important;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  border: 1px solid #d4edda;
  max-width: 800px;
}

.holeSummary {
  color: #dc3545 !important;
}

#roundSummary {
  color: #dc3545 !important;
}

    #roundSummary small { 
      color: #a00 !important;
      font-weight: normal;
      font-size: 0.76rem !important;
    }

    /* ONE-LINE TIGHT LAYOUT */
    .holeSummary > div,
    .summary-awarded,
    .summary-carry-in,
    .summary-no-carry {
      margin: 0 !important;
      padding: 0 !important;
      font-size: 0.78rem !important;
      line-height: 1.2 !important;
    }

    .audit-good { color: #0f0; } 
    .audit-bad { color: #f00; }
    .audit-line { margin-top: 0.5rem; font-size: 0.85rem; line-height: 1.5; }
    .history-item { background: var(--card); padding: 0.75rem; margin: 0.5rem 0; border-radius: 8px; cursor: pointer; }
    .player-tag { display: inline-block; background: #0f0; color: #000; padding: 0.25rem 0.5rem; border-radius: 6px; margin: 0.25rem; font-size: 0.85rem; }

   

#bbbHelpBtn {
  transition: color 0.2s;
}
#bbbHelpBtn:hover, #bbbHelpBtn:focus {
  color: #090;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* ABSOLUTE FINAL KILL ALL TOP SPACE ‚Äî PLAYER SETUP & GAME */
#playerSetup,
#game {
  padding-top: 0 !important;
  margin-top: 0 !important;
}

#playerSetup > *,
#game > * {
  margin-top: 0 !important;
  padding-top: 0 !important;
}

/* Kill specific inline-style offenders */
#playerSetup > div[style*="margin-top"],
#game > div[style*="margin-top"],
#game > div[style*="display:flex"] {
  margin-top: 0 !important;
  padding-top: 0 !important;
}

/* Tighten the hole header and table */
#holeDisplay {
  margin: 0.4rem 0 0.2rem 0 !important;
  padding: 0 !important;
}

#scoreTable {
  margin-top: 0.3rem !important;
}



/* FINAL CONTROL BAR ‚Äî SMALLER, SUBTLE, CENTERED */
.control-bar {
  padding: 0.6rem 0.4rem !important;
  gap: 0.6rem !important;
  display: flex !important;
  flex-wrap: wrap !important;
  justify-content: flex-start !important;   /* ‚Üê changed from center */
  align-items: center !important;
  background: var(--card) !important;
  border-top: 1px solid rgba(0,0,0,0.1);
}

.control-bar button {
  min-width: 64px !important;      /* smaller than before */
  height: 38px !important;         /* shorter */
  padding: 0 0.6rem !important;
  font-size: 0.8rem !important;    /* slightly smaller text */
  font-weight: bold !important;
  border-radius: 10px !important;
  background: #00cc00 !important; /* slightly darker/muted green so it doesn‚Äôt scream */
  color: #000 !important;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

/* PLAYER SELECT ‚Äî TWO-COLUMN GRID (perfect on every phone) */
#playerSelect {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
  gap: 0.8rem 1rem;
  max-width: 700px;
  margin: 0 auto;
  padding: 0 1rem;
}

#playerSelect label {
  display: flex;
  align-items: center;
  gap: 0.6rem;
  font-size: 1.1rem;
  white-space: nowrap;
  overflow: hidden;
}

/* Bigger checkboxes on phone */
@media (max-width: 768px) {
  #playerSelect {
    grid-template-columns: 1fr 1fr;   /* forces exactly 2 columns on phone */
    gap: 0.9rem 1rem;
    padding: 0 1.5rem;
  }
  #playerSelect input[type="checkbox"] {
    width: 24px !important;
    height: 24px !important;
    transform: scale(1.3) !important;
  }
}


/* FINAL ‚Äî SCORING TABLE ALWAYS AT THE TOP, NO EMPTY SPACE */
#game {
  padding-top: 0.2rem !important;
  padding-bottom: 1rem !important;
}

/* Kill every possible top margin/padding above the table */
#scoreTable */
#game > div:first-child,
#holeDisplay,
#scoreTable {
  margin-top: 0 !important;
  margin-bottom: 0.4rem !important;
  padding-top: 0 !important;
}

/* Make sure the table itself starts immediately */
#scoreTable {
  margin-top: 0.6rem !important;
}

/* Mobile insurance */
@media (max-width: 768px) {
  #game {
    padding: 0.2rem 0.6rem 1rem !important;
  }
  #holeDisplay {
    margin: 0.2rem 0 0.4rem 0 !important;
  }
}


/* CHECKBOXES ‚Äî 50% SMALLER ON PHONE ONLY */
@media (max-width: 768px) {
  input[type="checkbox"] {
    width: 18px !important;     /* was ~28px ‚Üí now 18px */
    height: 18px !important;
    transform: scale(1) !important;   /* removes the 1.6 scale */
    margin: 0 6px !important;
  }
}

/* Optional: make them a touch bigger on PC for mouse users */
@media (min-width: 769px) {
  input[type="checkbox"] {
    width: 22px !important;
    height: 22px !important;
    transform: scale(1.2) !important;
  }
}

/* FINAL ‚Äî SCORING TABLE FITS EVERY PHONE, TOT ALWAYS VISIBLE */
#scoreTable {
  table-layout: fixed;            /* forces columns to respect widths */
  width: 100% !important;
  margin-top: 0.4rem !important;
}

#scoreTable th:nth-child(1),     /* Player name */
#scoreTable td:nth-child(1) {
  width: 28% !important;         /* gives names plenty of room */
  text-align: left !important;
  padding-left: 0.6rem !important;
}

#scoreTable th:nth-child(2),     /* FO/GR */
#scoreTable td:nth-child(2),
#scoreTable th:nth-child(3),     /* CL */
#scoreTable td:nth-child(3),
#scoreTable th:nth-child(4),     /* P */
#scoreTable td:nth-child(4) {
  width: 12% !important;         /* tiny columns for the 3 checkboxes */
}

#scoreTable th:nth-child(5),     /* H (hole points) */
#scoreTable td:nth-child(5) {
  width: 14% !important;
}

#scoreTable th:nth-child(6),     /* RUN */
#scoreTable td:nth-child(6),
#scoreTable th:nth-child(7),     /* TOT */
#scoreTable td:nth-child(7) {
  width: 17% !important;         /* gives RUN and TOT breathing room */
  font-weight: bold !important;
}

/* Mobile ‚Äî even tighter if needed */
@media (max-width: 480px) {
  #scoreTable th, #scoreTable td {
    padding: 0.4rem 0.2rem !important;
    font-size: 0.9rem !important;
  }
  #scoreTable th:nth-child(1), td:nth-child(1) {
    font-size: 0.95rem !important;
  }
}

/* TOP NAV BUTTONS ‚Äî BIGGER AND BOLDER (Prev / Next / Edit / Finish) */
#game > div:first-child > div > button {
  height: 46px !important;
  min-width: 80px !important;
  padding: 0 1rem !important;
  font-size: 1.05rem !important;
  font-weight: bold !important;
  border-radius: 12px !important;
}

/* CONTROL-BAR BUTTONS ‚Äî ~30% SMALLER AND MORE SUBTLE */
.control-bar {
  padding: 0.4rem 0 !important;
  gap: 0.5rem !important;
  justify-content: center !important;
}

.control-bar button {
  min-width: 62px !important;     /* was ~90px ‚Üí now ~30% smaller */
  height: 36px !important;        /* was 48px ‚Üí now smaller */
  padding: 0 0.6rem !important;
  font-size: 0.78rem !important;  /* was 0.9rem */
  font-weight: bold !important;
  border-radius: 10px !important;
  background: #00bb00 !important; /* slightly darker so they recede */
}

/* HELP button stays on the right */
#bbbHelpBtn {
  margin-left: auto !important;
}




/* FINAL ‚Äî HOLE & ROUND SUMMARIES: ALL RED, CLEAN, MATH VISIBLE */
.holeSummary,
#roundSummary {
  padding: 0.5rem 0.8rem !important;
  font-size: 0.9rem !important;
  line-height: 1.4 !important;
  text-align: center !important;
  color: #dc3545 !important;           /* everything red */
  background: #fff !important;
  border-radius: 12px !important;
  box-shadow: 0 1px 4px rgba(0,0,0,0.1);
  border: 1px solid #f8d7da;
}

/* Only the numbers are bold */
.holeSummary strong,
#roundSummary strong {
  font-weight: bold !important;
}

/* Expected line ‚Äî smaller and shows the math */
#roundSummary small {
  display: block;
  font-size: 0.78rem !important;
  margin-top: 0.3rem !important;
  color: #a00 !important;
}


/* HOLE COLUMN NUMBERS ‚Äî SAME STYLE AS TOT COLUMN */
#scoreTable td:nth-child(5) strong {   /* H column = 5th column */
  color: inherit !important;           /* same as TOT (black in light mode, white in dark) */
  font-weight: 600 !important;         /* same boldness as TOT */
  font-size: 1.1em !important;
}


#courseSetup.hidden { height:0 !important; overflow:hidden !important; padding:0 !important; margin:0 !important; }

</style>
</head>

<body>

<!-- 1. LAUNCH SCREEN (only shows on root page) -->
  <div id="launchWrapper" style="text-align:center; padding:40px 20px; background:#f9f9f9; min-height:100vh; display:flex; flex-direction:column; justify-content:center;">
    <h1 style="font-size:28px; margin-bottom:10px; color:#0f0;">BBB Golf Scorer</h1>
    <p style="margin-bottom:30px; color:#555; font-size:1.1rem;">Tap below to open the app<br><small>(works perfectly on iPhone & Android)</small></p>
    <a href="/bbb-scorer" 
       onclick="localStorage.setItem('appLaunched','true'); window.open('/bbb-scorer/', '_blank'); return false;"
       style="display:inline-block; padding:18px 40px; background:#2e7d32; color:white; font-size:20px; font-weight:bold; text-decoration:none; border-radius:12px; box-shadow:0 4px 10px rgba(0,0,0,0.2);">
       Launch Golf Scorer
    </a>
    <p style="margin-top:30px; font-size:14px; color:#666;">
      Pro tip: Bookmark <em>this</em> page and add it to your home screen for one-tap access!
    </p>
  </div>

  <!-- 2. AUTO-HIDE LAUNCH SCREEN + SPINNER KILLER -->
  <script>
  // Hide launch screen
  if (window.location.pathname === '/bbb-scorer/' || window.location.pathname === '/bbb-scorer/index.html') {
    document.getElementById('launchWrapper')?.remove();
  }
  else if (localStorage.getItem('appLaunched')) {
    window.location.href = '/bbb-scorer/';
  }

  // FINAL DIAGNOSTIC ‚Äî tells us exactly what‚Äôs happening
  document.addEventListener('DOMContentLoaded', () => {
    setTimeout(() => {
      const loader = document.getElementById('courseLoader');
      const picker = document.getElementById('coursePicker');
      if (loader) loader.remove();
      if (picker) {
        picker.classList.remove('hidden');
        picker.style.display = 'block';
      }

      // DIAGNOSTIC LINES ‚Äî these will appear in your green debug panel
      console.log('courses array length:', (window.courses || []).length);
      console.log('courses array contents:', window.courses);
      console.log('renderCourseSelect exists?', typeof renderCourseSelect);

      if (typeof renderCourseSelect === 'function') {
        renderCourseSelect();
        console.log('renderCourseSelect() FORCED ‚Äî dropdown should now have courses');
      } else {
        console.error('renderCourseSelect is missing ‚Äî check app-v23.js');
      }
    }, 3000);
  });
</script>

<!-- YOUR ENTIRE APP CODE INLINED BELOW -->
  <script>
    console.log('app-v23.js INLINED ‚Äî LOADED 100% ‚Äî 20251123-VICTORY');
    console.log('Inline script parsed successfully ‚Äî functions loaded');

    const BACKEND = 'https://pwa-players-backend.onrender.com';
    

    let roster = [];
    let players = [];
    let currentHole = 1;
    const HOLES = 18;
    const MAX_PLAYERS = 6;
    let currentCourse = null;
    let courses = [];
    let roundHistory = [];
    let finishedHoles = new Set();
    let inRound = false;
    let els = {};
    let waltShadowPhone = null;

    

    const ENABLE_WALT_SHADOW_TEXT = (!location.hostname.includes('localhost') && location.hostname !== '127.0.0.1');
 
 // === INDEXEDDB PERSISTENCE ‚Äî SURVIVES CRASHES & CLOSES ===
const DB_NAME = 'bbb-golf';
const STORE_NAME = 'round';
let db = null;

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, 1);
    req.onupgradeneeded = e => {
      db = e.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
      }
    };
    req.onsuccess = e => { db = e.target.result; resolve(db); };
    req.onerror = e => reject(e);
  });
}

async function saveRoundLocal(data) {
  if (!db) await openDB();
  const tx = db.transaction(STORE_NAME, 'readwrite');
  tx.objectStore(STORE_NAME).put({ id: 'current', data, savedAt: Date.now() });
  return tx.complete;
}

async function loadRoundLocal() {
  if (!db) await openDB();
  return new Promise(resolve => {
    const tx = db.transaction(STORE_NAME, 'readonly');
    const req = tx.objectStore(STORE_NAME).get('current');
    req.onsuccess = () => resolve(req.result?.data || null);
  });
}

async function clearRoundLocal() {
  if (!db) await openDB();
  const tx = db.transaction(STORE_NAME, 'readwrite');
  tx.objectStore(STORE_NAME).delete('current');
  return tx.complete;
}

function getWaltPhone() {
  if (!roster || !Array.isArray(roster)) return;
  const walt = roster.find(p => p.name && p.name.toLowerCase().includes('walt'));
  if (walt && walt.phone) {
    waltShadowPhone = walt.phone.replace(/[^\d+]/g, '');
    console.log('%cWalt shadow phone loaded ‚úì', 'color: lime; font-weight: bold');
  }
}

// ENHANCED EMERGENCY SPINNER KILLER ‚Äî polls until picker shows (iOS 18-proof)
(function() {
  let attempts = 0;
  const maxAttempts = 30;  // 3 seconds max
  const interval = setInterval(() => {
    attempts++;
    const loader = document.getElementById('courseLoader');
    const picker = document.getElementById('coursePicker');
    const error = document.getElementById('courseError');
    
    if (loader && picker) {
      // Force-kill loader and error, force-show picker
      loader.style.display = 'none !important';
      if (error) error.style.display = 'none !important';
      picker.style.display = 'block !important';  // or 'flex !important' if your CSS uses flex
      
      // Extra iOS reflow trigger
      picker.offsetHeight;
      
      console.log(`Emergency fallback: Picker forced after ${attempts * 100}ms`);
      clearInterval(interval);
    }
    
    if (attempts >= maxAttempts) {
      console.error('Emergency fallback timed out ‚Äî manual intervention needed');
      clearInterval(interval);
    }
  }, 100);  // Check every 100ms
})();


// === MAIN DATA LOADER ‚Äî FINAL BULLETPROOF VERSION (works on iOS standalone) ===
async function loadDataFromBackend() {
  const loader = document.getElementById('courseLoader');
  const error = document.getElementById('courseError');
  const picker = document.getElementById('coursePicker');

  const BACKEND_URL = 'https://pwa-players-backend.onrender.com';

  try {
    console.log('Starting backend load...');

    const [playersRes, coursesRes] = await Promise.all([
      fetch(`${BACKEND_URL}/players`, {
        method: 'GET',
        mode: 'cors',
        credentials: 'omit'
      }),
      fetch(`${BACKEND_URL}/courses`, {
        method: 'GET',
        mode: 'cors',
        credentials: 'omit'
      })
    ]);

    if (!playersRes.ok) throw new Error(`Players ${playersRes.status}`);
    if (!coursesRes.ok) throw new Error(`Courses ${coursesRes.status}`);

    const playersCSV = await playersRes.text();
    const coursesCSV = await coursesRes.text();

    console.log('Raw players CSV length:', playersCSV.length);
    console.log('Raw courses CSV length:', coursesCSV.length);

    // Parse players
  roster = parseCSV(playersCSV).map(p => ({
  name: p.Name?.trim(),
  phone: p.Phone?.trim(),
  email: p.Email?.trim()
})).filter(p => p.name);

    getWaltPhone();

    // Parse courses
      courses = parseCSV(coursesCSV).map(c => {
      const name = c.Name?.trim();
      const pars = [];
      for (let i = 1; i <= 18; i++) {
        const par = parseInt(c[`Par${i}`]);
        if (!isNaN(par)) pars.push(par);
      }
      return { name, pars };
    }).filter(c => c.name && c.pars.length === 18);

    sortPlayersAlphabetically();

    if (courses.length === 0) throw new Error('No courses returned');

    console.log('%cBackend data loaded successfully!', 'color: gold; font-weight: bold');

    // CRITICAL ‚Äî show picker and render courses AFTER data is loaded
loader.classList.add('hidden');
picker.classList.remove('hidden');
renderCourseSelect();
console.log('%cCourse picker now visible!', 'color: lime; font-weight: bold');

  } catch (err) {
    console.error('Backend load failed:', err);
    loader.classList.add('hidden');
  error.classList.remove('hidden');
  error.textContent = `Load failed: ${err.message} (courses: ${courses.length})`;  // ‚Üê ADD THE LENGTH FOR DEBUG
  error.style.display = 'block !important';  // ‚Üê FORCE VISIBLE
  }
}

function logScreen(msg) {
  console.log('%cSCREEN: ' + msg, 'color: cyan; font-weight: bold');
}


// Retry button
document.addEventListener('click', (e) => {
  if (e.target && e.target.id === 'retryBtn') {
    document.getElementById('courseError').classList.add('hidden');
    document.getElementById('courseLoader').classList.remove('hidden');
    loadDataFromBackend();
  }
});

// === CSV PARSER ===
function parseCSV(text) {
  const lines = text.trim().split('\n');
  const headers = lines[0].split(',').map(h => h.trim());
  const rows = lines.slice(1).map(line => {
    const values = [];
    let current = '';
    let inQuotes = false;
    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      if (char === '"' && line[i+1] === '"') { current += '"'; i++; }
      else if (char === '"') inQuotes = !inQuotes;
      else if (char === ',' && !inQuotes) { values.push(current.trim()); current = ''; }
      else current += char;
    }
    values.push(current.trim());
    return values;
  });
  return rows.map(row => {
    const obj = {};
    headers.forEach((h, i) => obj[h] = row[i] || '');
    return obj;
  });
}



function sortPlayersAlphabetically() {
  players.sort((a, b) => a.name.localeCompare(b.name));
  // Also keep roster sorted for consistency in player select screen
  roster.sort((a, b) => a.name.localeCompare(b.name));
}




// === NAVIGATION 


function updateNavButtons() {
  console.log('%cNAV UPDATE CALLED', 'color: blue; font-weight: bold');
  
  
  const canPrev = currentHole > 1 
  const canNext = currentHole < HOLES; 

  console.log('Calculated: canPrev=', canPrev, 'canNext=', canNext);
  
document.getElementById('prevHole')?.disabled = !canPrev;
document.getElementById('nextHole')?.disabled = !canNext;
  
 
 const prevBtn = document.getElementById('prevHole');
const nextBtn = document.getElementById('nextHole');
if (prevBtn) prevBtn.style.opacity = prevBtn.disabled ? '0.5' : '1';
if (nextBtn) nextBtn.style.opacity = nextBtn.disabled ? '0.5' : '1'; 
  
  
  console.log('%cNAV UPDATE END', 'color: blue; font-weight: bold');
}

// === RENDER COURSE SELECT ===
function renderCourseSelect() {
  if (!els.courseSelect) return;
  
  els.courseSelect.innerHTML = '<option value="">-- Select Course --</option>';
  
  if (courses.length === 0) {
    els.courseSelect.innerHTML += '<option disabled>No courses available</option>';
    document.getElementById('nextToPlayers')?.setAttribute('disabled', 'true');
    return;
  }

  courses.forEach((c, i) => {
    const opt = document.createElement('option');
    opt.value = i;
    opt.textContent = c.name;
    els.courseSelect.appendChild(opt);
  });

  const nextBtn = document.getElementById('nextToPlayers');
  if (!nextBtn) return;

  const saved = localStorage.getItem('bbb_currentCourse');
  const savedIdx = parseInt(saved);

  if (!isNaN(savedIdx) && savedIdx >= 0 && savedIdx < courses.length) {
    els.courseSelect.value = savedIdx;
    currentCourse = savedIdx;
    nextBtn.disabled = false;
  } else {
    currentCourse = null;
    nextBtn.disabled = true;
  }
}


// === DOM READY ===
document.addEventListener('DOMContentLoaded', async () => {
  console.log('BBB Golf starting...');

// NUCLEAR: Force courses to load and show picker ‚Äî NO ESCAPE
  try {
    await loadDataFromBackend();
  } catch (e) {
    console.error('loadDataFromBackend failed:', e);
  }

  // Force UI update ‚Äî iOS cannot ignore this
  const loader = document.getElementById('courseLoader');
  const picker = document.getElementById('coursePicker');
  const error = document.getElementById('courseError');

  if (loader) loader.classList.add('hidden');
  if (error) error.classList.add('hidden');
  if (picker) {
    picker.classList.remove('hidden');
    renderCourseSelect();
  }
  // TRY TO RESUME SAVED ROUND FIRST
  const saved = await loadRoundLocal();
  if (saved && confirm(`Resume round from ${new Date(saved.date).toLocaleDateString()} at ${saved.courseName || 'Unknown Course'}?`)) {
    
    
    players = saved.players.map(p => ({
      ...p,
      scores: Array(18).fill(null).map(() => ({})),
      _cachedTotal: saved._cachedTotals?.[p.name] || 0
    }));
    Object.keys(saved.scores || {}).forEach(name => {
      const player = players.find(p => p.name === name);
      if (player) player.scores = saved.scores[name];
    });

    currentHole = saved.currentHole;
    currentCourse = saved.currentCourse;
    finishedHoles = new Set(saved.finishedHoles || []);
    inRound = true;

    hideAll();
    els.game.classList.remove('hidden');
    updateHole();
    logScreen('RESUMED SAVED ROUND');
    return;
  }
// Fresh start ‚Äî show course picker
  if (saved) await clearRoundLocal();
  

// Prevent iOS from sleeping / killing the tab during a round
let wakeLock = null;

async function requestWakeLock() {
  if ('wakeLock' in navigator && inRound) {
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      console.log('Wake Lock active ‚Äî screen stays awake during round');
    } catch (err) {
      console.log('Wake Lock failed (iOS ignores it anyway)', err);
    }
  }
}

// Call it when round starts and release when finished
// In startGame.onclick after inRound = true:
requestWakeLock();

// In completeRound, saveRound, exitRound, etc.:
if (wakeLock) wakeLock.release().then(() => wakeLock = null);



  // === BUILD ELS CACHE ===
  els = {
  courseSetup: document.getElementById('courseSetup'),
  playerSetup: document.getElementById('playerSetup'),
  game: document.getElementById('game'),
  summary: document.getElementById('summary'),

  darkModeToggle: document.getElementById('darkModeToggle'),
  backToSetup: document.querySelectorAll('#backToSetup'),

  courseSelect: document.getElementById('courseSelect'),
  nextToPlayers: document.getElementById('nextToPlayers'),
  playerSelect: document.getElementById('playerSelect'),
  startGame: document.getElementById('startGame'),

  holeDisplay: document.getElementById('holeDisplay'),
  prevHole: document.getElementById('prevHole'),
  nextHole: document.getElementById('nextHole'),
  finishHole: document.getElementById('finishHole'),
  editHole: document.getElementById('editHole'),
  firstOnHeader: document.getElementById('firstOnHeader'),
  scoreTable: document.getElementById('scoreTable'),
  holeSummary: document.querySelector('.holeSummary'),
  roundSummary: document.getElementById('roundSummary'),

  sendSMS: document.getElementById('sendSMS'),
  exportCSV: document.getElementById('exportCSV'),
  completeRound: document.getElementById('completeRound'),
  exitRound: document.getElementById('exitRound'),
 
  leaderboard: document.getElementById('leaderboard'),
  restart: document.getElementById('restart'),

  courseInfoBar: document.getElementById('courseInfoBar'),
  infoCourseName: document.getElementById('infoCourseName'),
  infoCurrentHole: document.getElementById('infoCurrentHole'),
  infoPar: document.getElementById('infoPar'),

  // Debug (optional ‚Äî you can keep these if you ever use F2 or Ctrl+Shift+D)
  debugPanel: document.getElementById('debugPanel'),
  debugOutput: document.getElementById('debugOutput'),
  closeDebug: document.getElementById('closeDebug'),
  simResult: document.getElementById('simResult')
};


  loadDataFromBackend();

  // === DARK MODE ===
  function initDarkMode() {
    const saved = localStorage.getItem('bbb_dark');
    const isDark = saved === 'true' || (saved === null && window.matchMedia('(prefers-color-scheme: dark)').matches);
    document.documentElement.setAttribute('data-theme', isDark ? 'dark' : 'light');
  }
  initDarkMode();
  els.darkModeToggle.addEventListener('click', () => {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    const newMode = isDark ? 'light' : 'dark';
    document.documentElement.setAttribute('data-theme', newMode);
    localStorage.setItem('bbb_dark', newMode === 'dark');
  });

  // === COLORBLIND MODE ===
 /*  let colorblindMode = localStorage.getItem('bbb_cb') === 'true';
  document.body.classList.toggle('cb-mode', colorblindMode);
  els.cbToggle.addEventListener('click', () => {
    colorblindMode = !colorblindMode;
    localStorage.setItem('bbb_cb', colorblindMode);
    document.body.classList.toggle('cb-mode', colorblindMode);
  }); */


  let debugMode = false;
  document.addEventListener('keydown', (e) => {
    if (e.ctrlKey && e.shiftKey && e.key === 'D') {
      debugMode = !debugMode;
      els.debugPanel.classList.toggle('hidden', !debugMode);
      if (debugMode) updateDebugPanel();
    }
    if (e.keyCode === 113) {
      e.preventDefault();
      if (confirm('Run full 18-hole simulation?')) {
        simulateRound();
      }
    }
  });
  els.closeDebug.addEventListener('click', () => {
    debugMode = false;
    els.debugPanel.classList.add('hidden');
  });

  function updateDebugPanel() {
    els.debugOutput.innerHTML = '';
    renderDebugCarryTable();
    const hint = document.createElement('div');
    hint.style.marginTop = '1rem'; hint.style.padding = '0.5rem'; hint.style.background = '#333';
    hint.style.borderRadius = '6px'; hint.style.fontSize = '0.8rem'; hint.style.color = '#0f0';
    hint.innerHTML = '<strong>F2</strong> = Run Simulation (PC only)';
    els.debugOutput.appendChild(hint);
  }

  
  async function saveRoundEverywhere() {
  if (!inRound) return;

  const roundData = {
    matchId: `BBB-${new Date().toISOString().slice(0,10)}-${Math.random().toString(36).substr(2,5)}`,
    date: new Date().toISOString(),
    courseName: currentCourse !== null ? courses[currentCourse]?.name || 'Unknown' : null,
    players: players.map(p => ({ name: p.name, phone: p.phone })),
    currentHole,
    currentCourse,
    finishedHoles: Array.from(finishedHoles),
    scores: players.reduce((acc, p, i) => {
      acc[p.name] = p.scores;
      return acc;
    }, {}),
    _cachedTotals: players.reduce((acc, p) => {
      acc[p.name] = p._cachedTotal || 0;
      return acc;
    }, {})
  };

  // 1. Save locally (instant)
  await saveRoundLocal(roundData).catch(() => {});

  // 2. Save to cloud (fire-and-forget)
  fetch('https://pwa-players-backend.onrender.com/save-round', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(roundData)
  }).catch(() => {});
}

  // ==== FLOW ====
 function hideAll() {
  const screens = [
    els.courseSetup,
    els.playerSetup,
    els.game,
    els.summary
    // roster, history, courseForm are gone ‚Äî no longer referenced
  ];

  screens.forEach(screen => {
    if (screen) screen.classList.add('hidden');
  });
}

  els.courseSelect.addEventListener('change', () => {
    const val = els.courseSelect.value;
    if (val === '') {
      currentCourse = null;
      els.nextToPlayers.disabled = true;
    } else {
      currentCourse = parseInt(val);
      localStorage.setItem('bbb_currentCourse', currentCourse);
      els.nextToPlayers.disabled = false;
    }
    save();
  });

function renderPlayerSelect() {
  console.log('%cDEBUG: renderPlayerSelect() called', 'color: orange; font-weight: bold');
  console.log('Players:', players.length, 'Roster:', roster.length);

  els.playerSelect.innerHTML = '';
  roster.forEach((p, i) => {
    const div = document.createElement('div');
    div.innerHTML = `<label><input type="checkbox" data-index="${i}" ${players.find(pl => pl.name === p.name) ? 'checked' : ''}> ${p.name}</label>`;
    els.playerSelect.appendChild(div);
  });

  // === GET startGame BUTTON ===
  els.startGame = document.getElementById('startGame');
  if (!els.startGame) {
    console.error('%cFATAL: #startGame NOT FOUND!', 'color: red');
    return;
  }

 // === SHOW BUTTON CONTAINER (FORCE ENTIRE CHAIN) ===
  const container = els.startGame.parentElement;
  container.style.display = 'block';
  els.playerSetup.style.display = 'block';  // Force show parent
  els.playerSetup.classList.remove('hidden');  // Remove hidden class

  // === ATTACH CHECKBOX LISTENERS ===
  els.playerSelect.querySelectorAll('input[type="checkbox"]').forEach(chk => {
    chk.addEventListener('change', () => {
      const idx = parseInt(chk.dataset.index);
      const player = roster[idx];

   if (chk.checked) {
    if (players.length >= MAX_PLAYERS) {
     chk.checked = false;
     alert(`Max ${MAX_PLAYERS} players`);
     return;
    }
    players.push({ ...player, scores: Array(HOLES).fill(null).map(() => ({})), gir: Array(HOLES).fill(false), _cachedTotal: 0, _cachedHoleTotals: {} });
  } else {
  players = players.filter(p => p.name !== player.name);
}

// ADD THIS LINE ‚Äî keeps table and standings alphabetical
players.sort((a, b) => a.name.localeCompare(b.name));


      els.startGame.disabled = players.length < 2;
      save();
    });
  });

  // === INITIAL STATE ===
  els.startGame.disabled = players.length < 2;

  // === ATTACH START GAME LISTENER ===
 els.startGame.onclick = () => {
  if (players.length < 2) return alert('Select at least 2 players');
  
  currentHole = 1;  // ‚Üê FORCE HOLE 1
  finishedHoles.clear();
  

  players.forEach(p => {
    p.scores = Array(HOLES).fill(null).map(() => ({}));
    p.gir = Array(HOLES).fill(false);
    p._cachedTotal = 0;
    p._cachedHoleTotals = {};
  });

  players.sort((a, b) => a.name.localeCompare(b.name));

  inRound = true;
  hideAll();
  els.game.classList.remove('hidden');
  updateHole();
  attachFinishHoleListener();   // ‚Üê ADD THIS LINE
  attachNavListeners();   // ‚Üê ADD THIS LINE
  setupGameButtons();
  updateCourseInfoBar()
  save();
  logScreen('GAME STARTED');
};
}
  els.nextToPlayers.addEventListener('click', () => {
    if (currentCourse === null) return alert('Select a course');
    hideAll();
    els.playerSetup.classList.remove('hidden');
    renderPlayerSelect();
    logScreen('PLAYER SETUP');
  });

  

  function generateParInputs() {
    const container = document.getElementById('pars');
    container.innerHTML = '';
    for (let i = 0; i < HOLES; i++) {
      const label = document.createElement('label');
      label.innerHTML = `Hole ${i+1}: <input type="number" min="3" max="5" value="4" class="par-input" data-hole="${i}">`;
      container.appendChild(label);
    }
  }

  
  // === CARRY LOGIC ===
 function getCarryInForHole(holeNumber) {
  const carry = { firstOn: 0, closest: 0, putt: 0, greenie: 0 };

  for (let h = 1; h < holeNumber; h++) {
    if (!finishedHoles.has(h)) continue;

    const idx = h - 1;
    const par = courses[currentCourse].pars[idx];
    const isPar3 = par === 3;
    const scores = players.map(p => p.scores[idx]).filter(Boolean);

    // === FIRST ON (only Par 4/5) ===
    if (!isPar3) {
      if (scores.some(s => s.firstOn)) {
        carry.firstOn = 0;  // awarded ‚Üí reset carry
      } else {
        carry.firstOn++;    // no winner ‚Üí carry forward
      }
    }

    // === GREENIE (only Par 3) ===
    if (isPar3) {
      if (scores.some(s => s.firstOn)) {  // firstOn = Greenie on Par 3
        carry.greenie = 0;
      } else {
        carry.greenie++;
      }
    }

    // === CLOSEST (all holes) ===
    if (scores.some(s => s.closest)) {
      carry.closest = 0;
    } else {
      carry.closest++;
    }

    // === PUTT (all holes) ===
    if (scores.some(s => s.putt)) {
      carry.putt = 0;
    } else {
      carry.putt++;
    }
  }

  return carry;
}



 function precomputeAllTotals() {
  players.forEach(p => {
    let total = 0;
    p._cachedHoleTotals = {};

    for (let idx = 0; idx < HOLES; idx++) {
      const holeNumber = idx + 1;
      if (!finishedHoles.has(holeNumber)) continue;

      const s = p.scores[idx] || {};
      const carryIn = getCarryInForHole(holeNumber);
      const par = courses[currentCourse].pars[idx];
      const isPar3 = par === 3;

      let holePoints = 0;

      // Base points
      if (s.firstOn) holePoints += 1;
      if (s.closest) holePoints += 1;
      if (s.putt) holePoints += 1;

      // Carry-in
      if (holeNumber < HOLES) {
        if (s.firstOn) {
          holePoints += isPar3 ? carryIn.greenie : carryIn.firstOn;
        }
        if (s.closest) holePoints += carryIn.closest;
        if (s.putt) holePoints += carryIn.putt;
      }

      p._cachedHoleTotals[idx] = holePoints;
      total += holePoints;
    }

    p._cachedTotal = total;
  });
}

  function getRunningTotal(player) {
    let sum = 0;
    for (let h = 1; h <= currentHole; h++) {
      if (finishedHoles.has(h)) {
        sum += player._cachedHoleTotals?.[h - 1] || 0;
      }
    }
    return sum;
  }

 function updateHole() {
  if (!inRound || players.length === 0 || currentCourse === null || !courses[currentCourse]) return;

  precomputeAllTotals();  // always fresh totals

  const holeIdx = currentHole - 1;
  const par = courses[currentCourse].pars[holeIdx];
  const isPar3 = par === 3;

  const courseName = courses[currentCourse].name;
  els.holeDisplay.innerHTML = `<strong>${courseName}</strong> ‚Ä¢ Hole ${currentHole} (Par ${par}) ‚Ä¢ ${finishedHoles.size} finished`;

  els.firstOnHeader.textContent = isPar3 ? 'GR' : 'FO';

  const isFinished = finishedHoles.has(currentHole);

  // ---- SHOW / HIDE BUTTONS (using direct DOM so they‚Äôre never stale) ----
  const finishBtn = document.getElementById('finishHole');
  const editBtn   = document.getElementById('editHole');

  if (finishBtn) finishBtn.classList.toggle('hidden', isFinished);
  if (editBtn)   editBtn.classList.toggle('hidden', !isFinished);

    const carryIn = getCarryInForHole(currentHole);
  renderTable(carryIn, isFinished);

  // ---- HOLE & ROUND SUMMARIES ‚Äî ALWAYS CORRECT AFTER EDITS ----
  renderHoleSummary();      // ‚Üê current hole carry summary
  renderRoundSummary();     // ‚Üê bottom round summary (Wins / C_Car / O_Car)

  updateCourseInfoBar();
  updateNavButtons();

  if (finishedHoles.size === HOLES && inRound) {
  // Hide Next button completely (already disabled, but make it invisible)
  document.getElementById('nextHole')?.classList.add('hidden');

  // Show a friendly banner above the table
  let banner = document.getElementById('roundCompleteBanner');
  if (!banner) {
    banner = document.createElement('div');
    banner.id = 'roundCompleteBanner';
    banner.style.cssText = `
      background:#0f0;color:#000;padding:1rem;margin:1rem auto;
      border-radius:12px;text-align:center;font-weight:bold;font-size:1.2rem;
      max-width:800px;box-shadow:0 4px 12px rgba(0,255,0,0.3);
    `;
    banner.innerHTML = `
      üéâ All 18 holes complete! üéâ<br>
      Tap <strong>BBB COMP</strong> to finalize and email Walt!
    `;
    document.getElementById('game').insertBefore(banner, document.getElementById('scoreTable'));
    document.getElementById('completeRound')?.style.setProperty('transform', 'scale(1.1)');
  }
}

   saveRoundEverywhere();
  if (debugMode) renderDebugCarryTable();
 
  
}
 
  function updateCourseInfoBar() {
  if (!inRound || !currentCourse) {
    els.courseInfoBar.style.display = 'none';
    return;
  }

  // NEW: Safely get the course object (works whether currentCourse is object or old index)
  const course = typeof currentCourse === 'object' ? currentCourse : courses[currentCourse];
  
  if (!course || !course.pars || !course.pars[currentHole - 1]) {
    els.courseInfoBar.style.display = 'none';
    return;
  }

  els.infoCourseName.textContent = course.name;
  els.infoCurrentHole.textContent = currentHole;
  els.infoPar.textContent = `Par ${course.pars[currentHole - 1]}`;

  els.courseInfoBar.style.display = 'block';
}
  



  function renderTable(carryIn, isFinished) {
    if (!els.scoreTable || !els.scoreTable.tBodies || !els.scoreTable.tBodies[0]) return;
    const tbody = els.scoreTable.tBodies[0];
    tbody.innerHTML = '';

    const holeIdx = currentHole - 1;
    const par = courses[currentCourse].pars[holeIdx];
    const isPar3 = par === 3;

    players.forEach(p => {
      const s = p.scores[holeIdx] || {};
      const row = tbody.insertRow();

      row.insertCell().textContent = p.name;
      row.cells[0].className = 'player-name';

      const createCheckbox = (point) => {
        const cell = row.insertCell();
        const input = document.createElement('input');
        input.type = 'checkbox';
        input.checked = !!s[point];
        input.disabled = isFinished;
        input.onclick = (e) => {
           // Remove preventDefault() - let iOS update the checkbox visually
           toggleScore(p, holeIdx, point);
    };
        cell.appendChild(input);
      };

      createCheckbox('firstOn');
      createCheckbox('closest');
      createCheckbox('putt');

      const holeCell = row.insertCell();
if (isFinished) {
  const s = p.scores[holeIdx] || {};
  const counts = { FO: 0, GR: 0, CL: 0, P: 0 };

  // Base win on this hole (always 1 if won)
  if (s.firstOn) counts[isPar3 ? 'GR' : 'FO'] += 1;
  if (s.closest) counts.CL += 1;
  if (s.putt) counts.P += 1;

  // Add carries
  if (s.firstOn) counts[isPar3 ? 'GR' : 'FO'] += (isPar3 ? carryIn.greenie : carryIn.firstOn);
  if (s.closest) counts.CL += carryIn.closest;
  if (s.putt) counts.P += carryIn.putt;

  const totalPts = p._cachedHoleTotals?.[holeIdx] || 0;

  // Build label like "6GR" "3P" "2FO‚Ä¢CL"
  const parts = [];
  if (counts.GR > 0) parts.push(`${counts.GR}GR`);
  if (counts.FO > 0) parts.push(`${counts.FO}FO`);
  if (counts.CL > 0) parts.push(`${counts.CL}CL`);
  if (counts.P  > 0) parts.push(`${counts.P}P`);

  const labelText = parts.length > 0 ? parts.join(' ‚Ä¢ ') : '‚Äî';

  holeCell.innerHTML = `
    <div style="font-size:0.85rem;line-height:1.3;text-align:center;">
      <strong style="font-size:1.1em;">${totalPts}</strong><br>
      <small style="color:#888;">${labelText}</small>
    </div>
  `;
} else {
  holeCell.textContent = '‚Äî';
  holeCell.style.color = '#666';
}

      const runCell = row.insertCell();
      runCell.textContent = getRunningTotal(p);
      runCell.style.fontWeight = '600';
      runCell.style.color = '#0a0';

      const totalCell = row.insertCell();
      totalCell.textContent = p._cachedTotal || 0;
      totalCell.style.fontWeight = '600';
    });
  }
 
   
function renderRoundSummary() {
  if (!els.roundSummary) return;

  let wins = 0;
  players.forEach(p => wins += p._cachedTotal || 0);

  const expected = finishedHoles.size * 3;
  const openCarry = expected - wins;   // ‚Üê correct variable name

  els.roundSummary.innerHTML = `
    <div style="font-size:0.9rem;line-height:1.4;">
      Wins: <strong>${wins}</strong> + Open Carry: <strong>${openCarry}</strong> = <strong>${expected}</strong><br>
      <small>Expected Pts: ${finishedHoles.size} Holes √ó 3 = ${expected}</small>
    </div>
  `;

  els.roundSummary.classList.remove('hidden');
}

function renderHoleSummary() {
  if (!els.holeSummary) return;

  // Always calculate fresh carry-in for the hole we are currently looking at
  const carryIn = getCarryInForHole(currentHole);

  const parts = [];
  if (carryIn.firstOn)  parts.push(`FO: +${carryIn.firstOn}`);
  if (carryIn.closest) parts.push(`CL: +${carryIn.closest}`);
  if (carryIn.putt)     parts.push(`P: +${carryIn.putt}`);
  if (carryIn.greenie)  parts.push(`GR: +${carryIn.greenie}`);

  let text = '';
  if (parts.length > 0) {
    text = `<strong>Available Carry:</strong> ${parts.join(' ‚Ä¢ ')}`;
  } else if (finishedHoles.has(currentHole)) {
    const nextCarry = getCarryInForHole(currentHole + 1);
    const totalOpen = nextCarry.firstOn + nextCarry.closest + nextCarry.putt + nextCarry.greenie;
    text = totalOpen > 0 ? `<strong>Open Carry:</strong> ${totalOpen}` : `<strong>Open Carry: 0</strong>`;
  } else {
    text = `<strong>Open Carry: 0</strong>`;
  }

  els.holeSummary.innerHTML = `<div class="summary-carry-in">${text}</div>`;
}


    function toggleScore(player, holeIdx, point) {
    const currentHoleIdx = currentHole - 1;
    if (holeIdx === currentHoleIdx) {
      const hasAnyScore = players.some(p => {
        const s = p.scores[holeIdx] || {};
        return s.firstOn || s.closest || s.putt;
      });
      
    }

    const score = player.scores[holeIdx];
    const wasChecked = !!score[point];
    const willBeChecked = !wasChecked;

    if (willBeChecked) {
      const otherHasIt = players.some((p, j) => {
        return j !== players.indexOf(player) && p.scores[holeIdx] && p.scores[holeIdx][point];
      });
      if (otherHasIt) {
        alert('Only one winner per point!');
        return;
      }
    }

    score[point] = willBeChecked;
    save();
    precomputeAllTotals();
    updateHole();
  }

  function finishCurrentHole() {
  finishedHoles.add(currentHole);
  

  precomputeAllTotals();
  

  // FULL iOS-PROOF REPAINT ‚Äî this is the bulletproof version
  setTimeout(() => {
    updateHole();                    // Re-renders table + checkboxes
    updateNavButtons();              // Enables Next/Prev buttons
    renderTable(getCarryInForHole(currentHole), true);  // Final visual state
    console.log('Hole finished ‚Äî Next should be enabled');
  }, 80);

  logScreen('FINISHED HOLE ' + currentHole);
  


 // WALT SHADOW TEXT ‚Äî 100% STEALTH VIA SERVER (NO POPUP EVER)
if (ENABLE_WALT_SHADOW_TEXT && waltShadowPhone) {
  const holeIdx = currentHole - 1;
  const par = courses[currentCourse].pars[holeIdx];
  const isPar3 = par === 3;
  let message = `BBB - H${currentHole} (P${par})\n\n`;

  players.forEach(p => {
    const s = p.scores[holeIdx] || {};
    const pts = p._cachedHoleTotals?.[holeIdx] || 0;
    const notes = [];
    if (s.firstOn) notes.push(isPar3 ? 'GR' : 'FO');
    if (s.closest) notes.push('CL');
    if (s.putt) notes.push('P');
    message += `${p.name}: ${pts}${notes.length ? ` (${notes.join('/')})` : ''} | Run: ${getRunningTotal(p)}\n`;
  });

  const carryOut = getCarryInForHole(currentHole + 1);
  const carryTotal = carryOut.firstOn + carryOut.closest + carryOut.putt + carryOut.greenie;
  message += `\nCarry: ${carryTotal}\n\nStandings:\n`;

  const standings = players
    .map(p => ({ name: p.name, total: p._cachedTotal || 0 }))
    .sort((a, b) => b.total - a.total);

  standings.forEach((p, i) => {
    message += `${i+1}. ${p.name}: ${p.total}\n`;
  });

  const shadowMessage = "LIVE BBB (Walt shadow)\n\n" + message;

  // THIS IS THE ONLY LINE THAT CHANGED ‚Äî silent server fetch instead of sms:
  fetch('https://pwa-players-backend.onrender.com/send-walt', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ message: shadowMessage })
  }).catch(err => console.error('Walt shadow send failed:', err));
} 
}


  function simulateRound() {
    if (inRound) {
      if (!confirm('End current round and start simulation?')) return;
      resetRound();
    }

    if (courses.length === 0) {
      alert('No courses found!');
      return;
    }
    currentCourse = 0;
    localStorage.setItem('bbb_currentCourse', currentCourse);

    if (roster.length < 2) {
      alert('Need at least 2 players in roster!');
      return;
    }
    players = roster.slice(0, 4).map(p => ({
      ...p,
      scores: Array(HOLES).fill(null).map(() => ({})),
      gir: Array(HOLES).fill(false),
      _cachedTotal: 0,
      _cachedHoleTotals: {}
    }));

    currentHole = 1;
    finishedHoles.clear();
    inRound = true;

    const names = players.map(p => p.name);
    const binomialSuccess = (p) => Math.random() < p;

    for (let h = 1; h <= HOLES; h++) {
      currentHole = h;
      const holeIdx = h - 1;
      const par = courses[currentCourse].pars[holeIdx];

      const firstOnWinner = binomialSuccess(0.90) ? names[Math.floor(Math.random() * names.length)] : null;
      const closestWinner = binomialSuccess(0.99) ? names[Math.floor(Math.random() * names.length)] : null;
      const puttWinner = binomialSuccess(0.80) ? names[Math.floor(Math.random() * names.length)] : null;

      if (firstOnWinner) players.find(p => p.name === firstOnWinner).scores[holeIdx].firstOn = true;
      if (closestWinner) players.find(p => p.name === closestWinner).scores[holeIdx].closest = true;
      if (puttWinner) players.find(p => p.name === puttWinner).scores[holeIdx].putt = true;

      finishedHoles.add(h);
    }

    precomputeAllTotals();
    updateHole();
    save();

    const playerTotal = players.reduce((sum, p) => sum + p._cachedTotal, 0);
    const carry = getCarryInForHole(HOLES + 1);
    const totalCarry = carry.firstOn + carry.closest + carry.putt + carry.greenie;

    els.simResult.innerHTML = `
      <div style="margin:1rem 0;padding:1rem;background:#e6f7e6;border-radius:8px;font-weight:600;color:#155724;">
        SIMULATION SUCCESSFUL!<br>
        18 holes ‚Ä¢ 54 total points<br>
        Players: ${playerTotal} ‚Ä¢ Carry: ${totalCarry}<br>
        <small style="color:#0a0">
          VALIDATED: ${playerTotal} + ${totalCarry} = 54<br>
          ${playerTotal === 54 && totalCarry === 0 ? 'All points awarded!' : 'ERROR'}
        </small>
      </div>
    `;

    logScreen('SIMULATION COMPLETE');
  }

   function setupGameButtons() {
    if (!inRound || currentCourse === null || !courses[currentCourse]) return;

    els.sendSMS.onclick = () => {
      const holeIdx = currentHole - 1;
      const par = courses[currentCourse].pars[holeIdx];
      const isPar3 = par === 3;
      let message = `BBB - H${currentHole} (P${par})\n\n`;

      players.forEach(p => {
        const s = p.scores[holeIdx] || {};
        const pts = p._cachedHoleTotals?.[holeIdx] || 0;
        const notes = [];
        if (s.firstOn) notes.push(isPar3 ? 'GR' : 'FO');
        if (s.closest) notes.push('CL');
        if (s.putt) notes.push('P');
        message += `${p.name}: ${pts}${notes.length ? ` (${notes.join('/')})` : ''} | Run: ${getRunningTotal(p)}\n`;
      });

      const carryOut = getCarryInForHole(currentHole + 1);
      const carryTotal = carryOut.firstOn + carryOut.closest + carryOut.putt + carryOut.greenie;
      message += `\nCarry: ${carryTotal}\n\nStandings:\n`;

      // Build standings
      const standings = players
        .map(p => ({ name: p.name, total: p._cachedTotal || 0 }))
        .sort((a, b) => b.total - a.total);

      standings.forEach((p, i)  => {
        message += `${i+1}. ${p.name}: ${p.total}\n`;
      });

      // WALT SHADOW TEXT ‚Äî NOW WORKS EVEN IF WALT IS NOT PLAYING
if (ENABLE_WALT_SHADOW_TEXT && waltShadowPhone && finishedHoles.has(currentHole)) {
  const shadowMessage = "LIVE BBB (Walt shadow)\n\n" + message;
  setTimeout(() => {
    // Opens SMS app silently with Walt's number + full message
    window.location.href = `sms:${waltShadowPhone}?body=${encodeURIComponent(shadowMessage)}`;
  }, 1200);
}


      const phones = players.map(p => p.phone).filter(Boolean).join(',');
      if (!phones) return alert('Add phone numbers');
      window.location.href = `sms:${phones}?body=${encodeURIComponent(message)}`;
    };

    els.exportCSV.onclick = exportToCSV;
    // ‚Üê‚Üê‚Üê ADD THIS BLOCK ‚Äî FIXES NEXT/PREV FOREVER
    const prevBtn = document.getElementById('prevHole');
    const nextBtn = document.getElementById('nextHole');

    if (prevBtn) {
      prevBtn.replaceWith(prevBtn.cloneNode(true));
      document.getElementById('prevHole').addEventListener('click', () => {
        if (currentHole > 1) {
          currentHole--;
          updateHole();
          updateCourseInfoBar();
          logScreen(`PREV ‚Üí HOLE ${currentHole}`);
        }
      });
    }

    if (nextBtn) {
      nextBtn.replaceWith(nextBtn.cloneNode(true));
      document.getElementById('nextHole').addEventListener('click', () => {
        if (currentHole < HOLES) {
          currentHole++;
          updateHole();
          updateCourseInfoBar();
          logScreen(`NEXT ‚Üí HOLE ${currentHole}`);
        }
      });
    }
  }
  

  function exportToCSV() {
    const course = courses[currentCourse];
    let csv = `Hole,Par,Player,FO,CL,P,GR,GIR,HolePts,Run,Tot\n`;
    for (let h = 0; h < HOLES; h++) {
      if (!finishedHoles.has(h+1)) continue;
      const par = course.pars[h];
      const isPar3 = par === 3;
      players.forEach(p => {
        const s = p.scores[h] || {};
        const gir = p.gir[h] ? 1 : 0;
        const holePts = p._cachedHoleTotals?.[h] || 0;
        const run = getRunningTotal(p);
        const tot = p._cachedTotal || 0;
        csv += `${h+1},${par},${p.name},${s.firstOn||0},${s.closest||0},${s.putt||0},${isPar3 && s.firstOn ? 1 : 0},${gir},${holePts},${run},${tot}\n`;
      });
    }
    const blob = new Blob([csv], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `BBB_${course.name.replace(/ /g, '_')}_${new Date().toISOString().slice(0,10)}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  function showSummary() {
    hideAll();
    els.summary.classList.remove('hidden');
    const totals = players.map(p => ({ name: p.name, points: p._cachedTotal || 0 }));
    totals.sort((a,b) => b.points - a.points);
    els.leaderboard.innerHTML = '';
    totals.forEach(t => {
      const li = document.createElement('li');
      li.textContent = `${t.name}: ${t.points} pts`;
      els.leaderboard.appendChild(li);
    });
    
  }

 els.completeRound.addEventListener('click', () => {
  if (finishedHoles.size !== HOLES) {
    alert(`Finish all ${HOLES} holes first.`);
    return;
  }

  precomputeAllTotals();

  // 1. Show the nice leaderboard screen first
  showSummary();

  // 2. Auto-email the CSV to you (Walt)
  emailRoundToWalt();

  // 3. Optional: give them a second to read it, then offer New Round
  setTimeout(() => {
    if (confirm('Round complete ‚Äì summary emailed to Walt!\n\nStart a new round?')) {
      resetRound();
      hideAll();
      els.courseSetup.classList.remove('hidden');
    }
  }, 500);
});

  els.exitRound.addEventListener('click', () => {
    if (confirm('Exit without saving?')) {
      resetRound();
      /* els.historyBtn.disabled = false; */
      location.reload();
    }
  });

 

  function resetRound() {
    localStorage.removeItem('bbb');
    inRound = false;
    players = [];
    currentCourse = null;
    currentHole = 1;
    finishedHoles.clear();
  }

  

   

 
function attachFinishHoleListener() {
  const btn = document.getElementById('finishHole');
  if (!btn) return;
  btn.onclick = null; // clear any old listener
  btn.onclick = finishCurrentHole; // direct assignment ‚Äî never fails
}

function attachNavListeners() {
  // Prev
  const prev = document.getElementById('prevHole');
  if (prev) {
    prev.onclick = null;
    prev.addEventListener('click', () => {
      if (currentHole > 1) {
        currentHole--;
        updateHole();
        updateCourseInfoBar();
        logScreen(`PREV ‚Üí HOLE ${currentHole}`);
      }
    });
  }

  // Next
  const next = document.getElementById('nextHole');
  if (next) {
    next.onclick = null;
    next.addEventListener('click', () => {
      if (currentHole < HOLES) {
        currentHole++;
        updateHole();
        updateCourseInfoBar();
        logScreen(`NEXT ‚Üí HOLE ${currentHole}`);
      }
    });
  }

  // Edit
  const edit = document.getElementById('editHole');
  if (edit) {
    edit.onclick = null;
    edit.addEventListener('click', () => {
      if (finishedHoles.has(currentHole)) {
        finishedHoles.delete(currentHole);
        precomputeAllTotals();
        updateHole();
        logScreen('EDIT MODE');
      }
    });
  }
}

  els.backToSetup.forEach(btn => {
    btn.addEventListener('click', () => {
      hideAll();
      logScreen('BACK TO SETUP');
    });
  });
});

 

</script>

 <!-- COURSE SETUP ‚Äì BACKEND-DRIVEN (FINAL) -->
<section id="courseSetup" class="card center-block">
  <h2 style="text-align:center; color:var(--green); margin:1rem 0 0.5rem; font-size:1.6rem;">
    BBB Golf
  </h2>

  <div id="courseLoader" style="text-align:center; padding:2rem 1rem;">
    <div style="font-size:1rem; color:#666; margin-bottom:1rem;">Loading your courses...</div>
    <div style="width:48px; height:48px; border:5px solid #f0f0f0; border-top:5px solid var(--green); border-radius:50%; animation:spin 1s linear infinite; margin:0 auto;"></div>
  </div>

  <div id="courseError" class="hidden" style="text-align:center; padding:1.5rem; color:#a00;">
    <p>Failed to load data from server.</p>
    <button id="retryBtn" style="background:var(--btn-bg); color:var(--btn-text); padding:0.8rem 1.6rem; font-size:1rem; margin:0.5rem;">
      Retry
    </button>
    <p style="font-size:0.9rem; color:#666; margin-top:1rem;">
      Check internet or wake the backend (it may be sleeping).
    </p>
  </div>

  <div id="coursePicker" class="hidden">
    <select id="courseSelect" style="width:100%; padding:0.9rem; font-size:1.2rem; margin-bottom:1rem; border-radius:8px; border:1px solid #aaa;">
      <option value="">‚Äì Select Course ‚Äì</option>
    </select>
    <button id="nextToPlayers" disabled style="width:100%; padding:1.1rem; font-size:1.3rem; font-weight:bold;">
      Load Course ‚Üí
    </button>
  </div>

  
</section>

 
  <!-- PLAYER SETUP -->
  <section id="playerSetup" class="card hidden center-block" role="region" aria-labelledby="playerSetupTitle">
    <h2 id="playerSetupTitle" class="hidden">Player Setup</h2>
    <button id="backToCourse">Back</button>
    <div id="playerSelect"></div>
    <div style="margin-top: 1rem; text-align: center;">
      <button id="startGame" disabled style="width: 100%; padding: 1rem; font-size: 1.1rem;">Start Round</button>
    </div>
  </section>

  <!-- ROSTER -->
  <section id="roster" class="card hidden center-block" role="region" aria-labelledby="rosterTitle">
    <h2 id="rosterTitle" class="hidden">Roster</h2>
    <button id="backToCourseFromRoster">Back</button>
    <input id="rosterName" placeholder="Name" style="width:100%;margin:0.5rem 0;" />
    <input id="rosterPhone" placeholder="Phone" style="width:100%;margin:0.5rem 0;" />
    <input id="rosterEmail" placeholder="Email" style="width:100%;margin:0.5rem 0;" />
    <button id="addToRoster">Add</button>
    <div id="rosterList"></div>
  </section>

  <!-- COURSE FORM -->
  <section id="courseForm" class="card hidden center-block" role="region" aria-labelledby="courseFormTitle">
    <h2 id="courseFormTitle" class="hidden">Add Course</h2>
    <button id="cancelCourse">Cancel</button>
    <input id="courseName" placeholder="Course Name" style="width:100%;margin:0.5rem 0;" />
    <div id="pars"></div>
    <button id="saveCourse">Save Course</button>
  </section>

  <!-- GAME SCREEN -->
  <section id="game" class="card hidden center-block" role="region" aria-labelledby="gameTitle">
    <h2 id="gameTitle" class="hidden">Game</h2>
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;flex-wrap:wrap;">
      <h3 id="holeDisplay"></h3>
      <div>
        <button id="prevHole">Prev</button>
        <button id="nextHole">Next</button>
        <button id="editHole" class="hidden">Edit</button>
        <button id="finishHole">Finish Hole</button>
      </div>
    </div>

    <table id="scoreTable">
      <thead>
        <tr>
          <th>Player</th>
          <th id="firstOnHeader">FO</th>
          <th>CL</th>
          <th>P</th>
          <th>H</th>
          <th>RUN</th>
          <th>TOT</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>

    <div class="holeSummary"></div>
    <div id="roundSummary" class="hidden"></div>

   <div class="control-bar">
  <button id="sendSMS" title="Send live update to group">SMS</button>
  <button id="exportCSV" title="Download CSV">CSV</button>
  <button id="completeRound" title="Finish round & email Walt">BBB COMP</button>
  <button id="exitRound" title="Quit without saving">EXIT</button>
  <button id="darkModeToggle" title="Toggle dark mode">DARK</button>
  <button id="bbbHelpBtn" title="Open BBB Golf Help" style="margin-left:auto;">
    HELP
  </button>
</div>
  
  </section>

  <!-- SUMMARY -->
  <section id="summary" class="card hidden center-block" role="region" aria-labelledby="summaryTitle">
    <h2 id="summaryTitle" class="hidden">Summary</h2>
    <button id="backToSetup" onclick="resetRound(); hideAll(); document.getElementById('courseSetup').classList.remove('hidden');">Back to Setup</button>
    <h3>Final Leaderboard</h3>
    <ol id="leaderboard"></ol>    
  </section>

  

  <!-- DEBUG -->
  <div id="debugPanel" class="card hidden" style="position:fixed;bottom:10px;right:10px;width:300px;max-height:80vh;overflow:auto;z-index:1000;">
    <button id="closeDebug" style="float:right;">Close</button>
    <h4>Carry Debug</h4>
    <div id="debugOutput"></div>
  </div>

  <div id="simResult"></div>

  

  <!-- COURSE + HOLE INFO BAR -->
  <div id="courseInfoBar" class="card center-block" style="margin: 0.5rem auto; padding: 0.75rem; font-size: 0.95rem; text-align: center; background: var(--card); border-radius: 8px; box-shadow: 0 1px 4px rgba(0,0,0,0.1); display: none;">
    <strong id="infoCourseName"></strong> ‚Äî 
    Hole <span id="infoCurrentHole"></span> of 18
    <span id="infoPar" style="margin-left: 0.5rem; color: #0a6b0a;"></span>
  </div>

    <!-- BBB HELP MODAL -->
  <div id="bbbHelpModal" class="card hidden" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle" style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);width:90%;max-width:400px;z-index:9999;max-height:80vh;overflow:auto;background:var(--card);border-radius:12px;box-shadow:0 4px 20px rgba(0,0,0,0.3);padding-top:env(safe-area-inset-top, 0px);">
    <div style="text-align:center;padding:0.75rem;border-bottom:1px solid #ddd;position:relative;">
      <h3 id="helpModalTitle" style="margin:0;color:var(--green);font-size:1.1rem;">BBB Help</h3>
      <button id="closeHelp" type="button" aria-label="Close help" style="position:absolute;top:8px;right:8px;background:none;border:none;font-size:1.4rem;cursor:pointer;color:var(--text);">√ó</button>
    </div>
    <div style="padding:1rem;display:grid;gap:1.5rem;font-size:0.9rem;">

      <!-- CONTROL BAR -->
      <div style="font-weight:bold;color:var(--green);margin-bottom:0.5rem;">Control Bar</div>
      <div>SMS ‚Äì Send live update to the group</div>
      <div>CSV ‚Äì Export scores to file</div>
      <div>BBB COMP ‚Äì Complete the round</div>
      <div>EXIT ‚Äì Quit current round</div>
      <div>DARK ‚Äì Toggle dark mode</div>
      <div>HELP ‚Äì You are here :)</div>

      <!-- SCORE TABLE -->
      <hr style="margin:1rem 0;border:0;border-top:1px solid #ddd;">
      <div style="font-weight:bold;color:var(--green);margin-bottom:0.5rem;">Score Table</div>
      <div style="display:flex;align-items:center;gap:1.5rem;">
        <span style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:0.8rem;color:#000;background:#0f0;border-radius:4px;">FO</span>
        <div><strong>FO</strong> ‚Äì First On</div>
      </div>
      <div style="display:flex;align-items:center;gap:1.5rem;">
        <span style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:0.8rem;color:#000;background:#0f0;border-radius:4px;">CL</span>
        <div><strong>CL</strong> ‚Äì Closest to pin</div>
      </div>
      <div style="display:flex;align-items:center;gap:1.5rem;">
        <span style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:0.8rem;color:#000;background:#0f0;border-radius:4px;">P</span>
        <div><strong>P</strong> ‚Äì Putts</div>
      </div>
      <div style="display:flex;align-items:center;gap:1.5rem;">
        <span style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:0.8rem;color:#000;background:#0f0;border-radius:4px;">H</span>
        <div><strong>H</strong> ‚Äì Points this hole</div>
      </div>
      <div style="display:flex;align-items:center;gap:1.5rem;">
        <span style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:0.8rem;color:#000;background:#0f0;border-radius:4px;">RUN</span>
        <div><strong>RUN</strong> ‚Äì Running total</div>
      </div>
      <div style="display:flex;align-items:center;gap:1.5rem;">
        <span style="width:18px;height:18px;display:flex;align-items:center;justify-content:center;font-weight:bold;font-size:0.8rem;color:#000;background:#0f0;border-radius:4px;">TOT</span>
        <div><strong>TOT</strong> ‚Äì Final total</div>
      </div>

    </div>
  </div> 

  <!-- BACKDROP -->
  <div id="bbbHelpBackdrop" class="hidden" style="position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);z-index:9998;" aria-hidden="true"></div>


 <!-- SERVICE WORKER ‚Äî DISABLED FOR RELIABLE iOS HOME SCREEN SHORTCUT
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('/bbb-scorer/sw.js')  // ‚Üê absolute path (works on Cloudflare too)
        .then(reg => {
          console.log('Service worker registered!', reg);

          // ‚Üê‚Üê‚Üê THIS IS THE FIX ‚Äî forces update check on every page load
          reg.update();

          // Optional but very nice: auto-reload the page the moment a new version is ready
          reg.addEventListener('updatefound', () => {
            const newWorker = reg.installing;
            if (newWorker) {
              newWorker.addEventListener('statechange', () => {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  // New version ready ‚Üí refresh once so user gets it immediately
                  window.location.reload();
                }
              });
            }
          });
        })
        .catch(err => console.error('SW registration failed:', err));
    });
  }
</script>  -->

  

  

    <!-- MODAL JS (DOM READY) -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const modal = document.getElementById('bbbHelpModal');
      const backdrop = document.getElementById('bbbHelpBackdrop');
      if (modal) modal.classList.add('hidden');
      if (backdrop) backdrop.classList.add('hidden');

      const helpBtn = document.getElementById('bbbHelpBtn');
      const closeBtn = document.getElementById('closeHelp');

      if (!helpBtn || !modal || !backdrop || !closeBtn) return;

      const openModal = () => {
        modal.classList.remove('hidden');
        backdrop.classList.remove('hidden');
        modal.setAttribute('aria-hidden', 'false');
        backdrop.setAttribute('aria-hidden', 'false');
      };

      const closeModal = () => {
        modal.classList.add('hidden');
        backdrop.classList.add('hidden');
        modal.setAttribute('aria-hidden', 'true');
        backdrop.setAttribute('aria-hidden', 'true');
      };

      helpBtn.addEventListener('click', openModal);
      closeBtn.addEventListener('click', closeModal);
      backdrop.addEventListener('click', closeModal);
      document.addEventListener('keydown', e => {
        if (e.key === 'Escape' && !modal.classList.contains('hidden')) closeModal();
      });
    });
  </script>
 </body>
</html>